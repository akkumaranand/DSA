// =================================================================Q1) Rotate Array =============================================================================================================
// method 1 ;
space complexity : O(n) and time complexity O(n)
//===========>>>>> very very brute force code <<<<<<========================================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     // crete duplicate vector 
     vector<int>duplicate(nums);
     int i = 0;
     while(i < (n-k)){
       nums[i+k] =  duplicate[i] ;
       i++;
     }

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};
// ======>>> better than previous <<=================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {

      vector<int> temp(nums.size());

      for(int i = 0; i<nums.size() ; i++){
          temp[(i+k)%nums.size()] = nums[i];   // importnat hai cycle me add karne ke liye hai   temp % (n)==>>> cycle karne ke liyeee
            
     }

     ///copy temp into num vector
       nums = temp;// to avoid overwrite

    }
};
=========>>>>>  method 2  <<<===========================
// with space optimisation
// space compplexity O(k)
// time complexity :- O(n)
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     
     // nums me hi change kar lennge 
     int i = n-k-1;
     int s = n-1;
     while(i >=0){
         nums[s] = nums[i];
        i--;
        s--;
     }
     

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};

//  ======================>>>> Most optimal code <<<=======================
clear nahi hai ====== >>> karna hai latter jab time mille 
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;

        if (k == 0) return; // No rotation needed

        int count = 0; // Count the number of elements we have moved
        int start = 0; // Start index of the current cycle

        while (count < n) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                swap(nums[next], prev);
                current = next;
                count++;
            } while (current != start);
            start++; // Move to the next cycle
        }
    }
};

//Q2)======================================================================>>>> Q2) Move Zero's to End  <<<<<<<<<=================================================================================================
//====>>>> brute force approach 
vector<int> moveZeros(int n, vector<int> a) {
    // Write your code here.
    vector<int> temp;
    for(int i = 0; i<n ; i++){
        if(a[i]!= 0){
            // temp.push_back(a[i]);
            // same hai 
            temp.emplace_back(a[i]);
        }
    }

    for(int j= 0 ; j<n ; j++){
        if(a[j]== 0){
            temp.push_back(a[j]);
        }
    }
   return temp;
}
//====>>>> optimal approach ===>>> With the help of double pointer 
vector<int> moveZeros(int n, vector<int> a) {
    
        int j =0;
        for(int i = 0; i<a.size() ; i++){
            if(a[i] != 0){
                a[j]= a[i];
                j++;
            }
        }
        while(j<a.size()){
            a[j] = 0;
            j++;
        }
        
    return a;    

};
// =============================>>>> Q3) Merge 2 Sorted Array  <<<<<===================================================================================================================================================================
// pahle merge with the help of two pointer 
// temp vector jisme duplicate ko nahi dalna and then return ans;
#include <vector>

using namespace std;

vector<int> sortedArray(vector<int> a, vector<int> b) {
    int i = 0;
    int j = 0;
    vector<int> c;

    while (i < a.size() && j < b.size()) {
        if (a[i] <= b[j]) {
            c.push_back(a[i]);
            i++;
        } else if (a[i] > b[j]) {
            c.push_back(b[j]);
            j++;
        } 
    }
    // duplicate ayenge hi aane do last me usko handle karge bss or koiii dikkat nahi hai
    // Add remaining elements from a and b if any
    while (i < a.size()) {
        c.push_back(a[i]);
        i++;
    }
    while (j < b.size()) {
        c.push_back(b[j]);
        j++;
    }
    
    // Removing duplicates
    vector<int> result;
    for (int i = 0; i < c.size(); i++) {
        if (i == 0 || c[i] != c[i - 1]) { // checking if current element is different from previous one
            result.push_back(c[i]);
        }
    }



    return result;
}
//======>>>>> short code , but  not optimised =====>>>>
#include <vector>

using namespace std;

vector<int> sortedArray(vector<int> a, vector<int> b) {
    int i = 0;
    int j = 0;
    vector<int> c;

// ======================================================= More important how to do that =================================
    while (i < a.size() || j < b.size()) {                                                                             // =
        if (i < a.size() && (j == b.size() || a[i] < b[j])) {                                                          // =
            c.push_back(a[i]);
            i++;                                                                                                       // =
        } else if (j < b.size() && (i == a.size() || b[j] < a[i])) {
            c.push_back(b[j]);                                                                                         // =
            j++;
        } else {                                                                                                       // =
            c.push_back(a[i]);                  
            i++;
            j++;                                                                                                       // =
        }
    }
                                                                                                                       //=
// ========================================================================================================================

    // Removing duplicates from c
    if (!c.empty()) {
        vector<int> result;
        result.push_back(c[0]);
        for (int k = 1; k < c.size(); ++k) {
            if (c[k] != c[k - 1]) {
                result.push_back(c[k]);
            }
        }
        c = result;
    }

    return c;
}


//==============================================Q4)Missing Number==========================================================================================================================================================
==>>> brute firce code 
#include<unordered_map>
class Solution {
public:
    int missingNumber(vector<int>& nums) {
      // find the largest element in the nums
      unordered_map<int, int> visited;
      int largest = INT_MIN;
      for(int i = 0 ; i < nums.size() ; i++) if(nums[i] > largest) largest = nums[i] ;
      for(int i = 0 ; i <= largest ; i++) visited[i] = 1;
      for(int i = 0 ; i< nums.size(); i++) visited[nums[i]] = 0;

      for(auto s : visited){
        if(s.second  == 1){
            return s.first;
        }
      }
     return largest+1;
    }
};

// =====>>>>> method 2 <<<<<============
// better or optimal code
#include<unordered_map>
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int sum = (n*(n+1))/2;
        int currSum = 0;
        for(int i=0;i<n;i++)
            currSum += nums[i];
        return sum-currSum;
    }
};


//================================================Q5)Find The Single Element =======================================================================================================================================
// ==========>>>>>brute code   time complexity : O(N2)  space complexity : #include <bits/stdc++.h>
using namespace std;

int getSingleElement(vector<int> &arr) {
    // Size of the array:
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        int num = arr[i]; // selected element
        int cnt = 0;

        //find the occurrence using linear search:
        for (int j = 0; j < n; j++)   if (arr[j] == num) cnt++;
        if (cnt == 1) return num;
    }
    return -1;
}


//  code space complexity :- O(n) and time complexity :- O(n)   ====================================
#include<vector>
#include<unordered_map>

int getSingleElement(vector<int> &arr){
	// Write your code here.	
	unordered_map<int , int> visited;
	for(int i = 0; i< arr.size() ; i++){
		visited[arr[i]]++;
	}

	for(auto  s : visited){
		if(s.second < 2){
			return s.first;
		}
	};

	return -1;
}
 // ========================>>>>>>>  OPTIMAL CODE <<<<<<=================
  XOR of two same numbers is always 0 i.e. a ^ a = 0. ←Property 1.
  XOR of a number with 0 will result in the number itself i.e. 0 ^ a = a.  ←Property 2
  //====>>> space complexity :- O(1)
  //====>>> time complexity  :- O(n)


  class Solution {
  public:
    int singleNumber(vector<int>& nums) {
        // method 2 
        int xorr = 0;
        for(int i = 0 ; i < nums.size() ; i++){
            xorr = xorr ^ nums[i];
        }
        return xorr;
    }
};



//=============================================== Q6) Product of Array Except Self =================================================================================================================================
//   ======== >>>brute force code <<<========
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n,1);
        int j = 0;
        for (int j = 0; j < n; ++j)
        {
            int index = (j +1 ) % n;
            int sum = 1 ;
            int count = 0;
            while(count < n-1){
             sum = sum * nums[index];
             index = (index + 1) %n;
             count++;
            }
            ans[j] = sum;
            
        }
        return ans;
    }
};
// =========>> More better  <<===================================================
   ==>> average time complexity  :- O(n) but worse time complexity :- O(n*n)
   ==>> space complexity :- O(n)
   class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        
        vector<int> ans;

        int product = 1;
        for (int i : nums) {
            product *= i;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != 0) {
                ans.push_back(product / nums[i]);
            } else {
                int act_product = 1;
                for (int j = 0; j < nums.size(); j++) {
                    if (j != i) {
                        act_product *= nums[j];
                    }
                }
                ans.push_back(act_product);
            }
        }
        return ans;
    }
};

// =====>>>> further optimised this code  <<<<<=================
time complexity :- O(n) and space complexity :- O(n) worse and average time 
=====>>> method of left and right array prodect and handling edges case <<<<<==========
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
    
        vector<int> left(n,1);
        vector<int> right(n,1);

        // left product of the array element 
        // int se hi jo jayega only to problem nahi hoga previous se multiply karna hai only 
        int leftProduct = 1;
        for(int i = 0 ; i < nums.size() ; i++){
            left[i] = leftProduct * nums[i];
            leftProduct = left[i];
        }
        // right product of array element
        int rightproduct = 1;
        for(int i = n-1 ; i>= 0 ; i --){
            right[i] = rightproduct * nums[i];
            rightproduct = right[i];
        }
        
        // Now multiplication of both the array 
        for(int i = 0 ; i < nums.size() ; i++){
            if(i == 0){
                nums[0] = right[1];
            }
            else if(i == n-1){
                nums[n-1] = left[n-2];
            }else{
                nums[i] = left[i-1] * right[i+1];
            }
        }
     return nums;
    }
};
//=======>>>>>> most optimal code  <<===============  
// =====>>>  with the help of DP  <<<=======


// ===========================================================                                   =================================================================================================================
