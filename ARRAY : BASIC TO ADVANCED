// =================================================================Q1) Rotate Array =============================================================================================================
// method 1 ;
space complexity : O(n) and time complexity O(n)
//===========>>>>> very very brute force code <<<<<<========================================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     // crete duplicate vector 
     vector<int>duplicate(nums);
     int i = 0;
     while(i < (n-k)){
       nums[i+k] =  duplicate[i] ;
       i++;
     }

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};
// ======>>> better than previous <<=================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {

      vector<int> temp(nums.size());

      for(int i = 0; i<nums.size() ; i++){
          temp[(i+k)%nums.size()] = nums[i];   // importnat hai cycle me add karne ke liye hai   temp % (n)==>>> cycle karne ke liyeee
            
     }

     ///copy temp into num vector
       nums = temp;// to avoid overwrite

    }
};
=========>>>>>  method 2  <<<===========================
// with space optimisation
// space compplexity O(k)
// time complexity :- O(n)
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     
     // nums me hi change kar lennge 
     int i = n-k-1;
     int s = n-1;
     while(i >=0){
         nums[s] = nums[i];
        i--;
        s--;
     }
     

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};

//  ======================>>>> Most optimal code <<<=======================
clear nahi hai ====== >>> karna hai latter jab time mille 
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;

        if (k == 0) return; // No rotation needed

        int count = 0; // Count the number of elements we have moved
        int start = 0; // Start index of the current cycle

        while (count < n) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                swap(nums[next], prev);
                current = next;
                count++;
            } while (current != start);
            start++; // Move to the next cycle
        }
    }
};

//Q2)======================================================================>>>> Q2) Move Zero's to End  <<<<<<<<<=================================================================================================
//====>>>> brute force approach 
vector<int> moveZeros(int n, vector<int> a) {
    // Write your code here.
    vector<int> temp;
    for(int i = 0; i<n ; i++){
        if(a[i]!= 0){
            // temp.push_back(a[i]);
            // same hai 
            temp.emplace_back(a[i]);
        }
    }

    for(int j= 0 ; j<n ; j++){
        if(a[j]== 0){
            temp.push_back(a[j]);
        }
    }
   return temp;
}
//====>>>> optimal approach ===>>> With the help of double pointer 
vector<int> moveZeros(int n, vector<int> a) {
    
        int j =0;
        for(int i = 0; i<a.size() ; i++){
            if(a[i] != 0){
                a[j]= a[i];
                j++;
            }
        }
        while(j<a.size()){
            a[j] = 0;
            j++;
        }
        
    return a;    

};
// =============================>>>> Q3) Merge 2 Sorted Array  <<<<<===================================================================================================================================================================
// pahle merge with the help of two pointer 
// temp vector jisme duplicate ko nahi dalna and then return ans;
#include <vector>

using namespace std;

vector<int> sortedArray(vector<int> a, vector<int> b) {
    int i = 0;
    int j = 0;
    vector<int> c;

    while (i < a.size() && j < b.size()) {
        if (a[i] <= b[j]) {
            c.push_back(a[i]);
            i++;
        } else if (a[i] > b[j]) {
            c.push_back(b[j]);
            j++;
        } 
    }
    // duplicate ayenge hi aane do last me usko handle karge bss or koiii dikkat nahi hai
    // Add remaining elements from a and b if any
    while (i < a.size()) {
        c.push_back(a[i]);
        i++;
    }
    while (j < b.size()) {
        c.push_back(b[j]);
        j++;
    }
    
    // Removing duplicates
    vector<int> result;
    for (int i = 0; i < c.size(); i++) {
        if (i == 0 || c[i] != c[i - 1]) { // checking if current element is different from previous one
            result.push_back(c[i]);
        }
    }



    return result;
}
//======>>>>> short code , but  not optimised =====>>>>
#include <vector>

using namespace std;

vector<int> sortedArray(vector<int> a, vector<int> b) {
    int i = 0;
    int j = 0;
    vector<int> c;

// ======================================================= More important how to do that =================================
    while (i < a.size() || j < b.size()) {                                                                             // =
        if (i < a.size() && (j == b.size() || a[i] < b[j])) {                                                          // =
            c.push_back(a[i]);
            i++;                                                                                                       // =
        } else if (j < b.size() && (i == a.size() || b[j] < a[i])) {
            c.push_back(b[j]);                                                                                         // =
            j++;
        } else {                                                                                                       // =
            c.push_back(a[i]);                  
            i++;
            j++;                                                                                                       // =
        }
    }
                                                                                                                       //=
// ========================================================================================================================

    // Removing duplicates from c
    if (!c.empty()) {
        vector<int> result;
        result.push_back(c[0]);
        for (int k = 1; k < c.size(); ++k) {
            if (c[k] != c[k - 1]) {
                result.push_back(c[k]);
            }
        }
        c = result;
    }

    return c;
}


//========================================================================================================================================================================================================
