// =================================================================Q1) Rotate Array =============================================================================================================
// method 1 ;
space complexity : O(n) and time complexity O(n)
//===========>>>>> very very brute force code <<<<<<========================================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     // crete duplicate vector 
     vector<int>duplicate(nums);
     int i = 0;
     while(i < (n-k)){
       nums[i+k] =  duplicate[i] ;
       i++;
     }

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};
// ======>>> better than previous <<=================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {

      vector<int> temp(nums.size());

      for(int i = 0; i<nums.size() ; i++){
          temp[(i+k)%nums.size()] = nums[i];   // importnat hai cycle me add karne ke liye hai   temp % (n)==>>> cycle karne ke liyeee
            
     }

     ///copy temp into num vector
       nums = temp;// to avoid overwrite

    }
};
=========>>>>>  method 2  <<<===========================
// with space optimisation
// space compplexity O(k)
// time complexity :- O(n)
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     
     // nums me hi change kar lennge 
     int i = n-k-1;
     int s = n-1;
     while(i >=0){
         nums[s] = nums[i];
        i--;
        s--;
     }
     

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};

//  ======================>>>> Most optimal code <<<=======================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;

        if (k == 0) return; // No rotation needed

        int count = 0; // Count the number of elements we have moved
        int start = 0; // Start index of the current cycle

        while (count < n) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                swap(nums[next], prev);
                current = next;
                count++;
            } while (current != start);
            start++; // Move to the next cycle
        }
    }
};

//============================================================================================================================================================================================================
