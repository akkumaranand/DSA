// =================================================================Q1) Rotate Array =============================================================================================================
// method 1 ;
space complexity : O(n) and time complexity O(n)
//===========>>>>> very very brute force code <<<<<<========================================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     // crete duplicate vector 
     vector<int>duplicate(nums);
     int i = 0;
     while(i < (n-k)){
       nums[i+k] =  duplicate[i] ;
       i++;
     }

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};
// ======>>> better than previous <<=================================
class Solution {
public:
    void rotate(vector<int>& nums, int k) {

      vector<int> temp(nums.size());

      for(int i = 0; i<nums.size() ; i++){
          temp[(i+k)%nums.size()] = nums[i];   // importnat hai cycle me add karne ke liye hai   temp % (n)==>>> cycle karne ke liyeee
            
     }

     ///copy temp into num vector
       nums = temp;// to avoid overwrite

    }
};
=========>>>>>  method 2  <<<===========================
// with space optimisation
// space compplexity O(k)
// time complexity :- O(n)
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n = nums.size();
      // special condition ko bhi solve karna hoga 
      k= k % n; // important part hai  
      vector<int>stored(k);
      // Right sift karna hai 
      int j = 0;
      for(int i = n - k ; i<n  ; i++){
        stored[j] = nums[i];
        j++;
      }
     
     // nums me hi change kar lennge 
     int i = n-k-1;
     int s = n-1;
     while(i >=0){
         nums[s] = nums[i];
        i--;
        s--;
     }
     

     // copy of k element of start
     for(int i = 0 ; i<stored.size() ; i++){
        nums[i] = stored[i];
     }
    }

};

//  ======================>>>> Most optimal code <<<=======================
clear nahi hai ====== >>> karna hai latter jab time mille 
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;

        if (k == 0) return; // No rotation needed

        int count = 0; // Count the number of elements we have moved
        int start = 0; // Start index of the current cycle

        while (count < n) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                swap(nums[next], prev);
                current = next;
                count++;
            } while (current != start);
            start++; // Move to the next cycle
        }
    }
};

//Q2)======================================================================>>>> Q2) Move Zero's to End  <<<<<<<<<=================================================================================================
//====>>>> brute force approach 
vector<int> moveZeros(int n, vector<int> a) {
    // Write your code here.
    vector<int> temp;
    for(int i = 0; i<n ; i++){
        if(a[i]!= 0){
            // temp.push_back(a[i]);
            // same hai 
            temp.emplace_back(a[i]);
        }
    }

    for(int j= 0 ; j<n ; j++){
        if(a[j]== 0){
            temp.push_back(a[j]);
        }
    }
   return temp;
}
//====>>>> optimal approach ===>>> With the help of double pointer 
vector<int> moveZeros(int n, vector<int> a) {
    
        int j =0;
        for(int i = 0; i<a.size() ; i++){
            if(a[i] != 0){
                a[j]= a[i];
                j++;
            }
        }
        while(j<a.size()){
            a[j] = 0;
            j++;
        }
        
    return a;    

};
// =============================>>>> Q3) Merge 2 Sorted Array  <<<<<===================================================================================================================================================================
// pahle merge with the help of two pointer 
// temp vector jisme duplicate ko nahi dalna and then return ans;
#include <vector>

using namespace std;

vector<int> sortedArray(vector<int> a, vector<int> b) {
    int i = 0;
    int j = 0;
    vector<int> c;

    while (i < a.size() && j < b.size()) {
        if (a[i] <= b[j]) {
            c.push_back(a[i]);
            i++;
        } else if (a[i] > b[j]) {
            c.push_back(b[j]);
            j++;
        } 
    }
    // duplicate ayenge hi aane do last me usko handle karge bss or koiii dikkat nahi hai
    // Add remaining elements from a and b if any
    while (i < a.size()) {
        c.push_back(a[i]);
        i++;
    }
    while (j < b.size()) {
        c.push_back(b[j]);
        j++;
    }
    
    // Removing duplicates
    vector<int> result;
    for (int i = 0; i < c.size(); i++) {
        if (i == 0 || c[i] != c[i - 1]) { // checking if current element is different from previous one
            result.push_back(c[i]);
        }
    }



    return result;
}
//======>>>>> short code , but  not optimised =====>>>>
#include <vector>

using namespace std;

vector<int> sortedArray(vector<int> a, vector<int> b) {
    int i = 0;
    int j = 0;
    vector<int> c;

// ======================================================= More important how to do that =================================
    while (i < a.size() || j < b.size()) {                                                                             // =
        if (i < a.size() && (j == b.size() || a[i] < b[j])) {                                                          // =
            c.push_back(a[i]);
            i++;                                                                                                       // =
        } else if (j < b.size() && (i == a.size() || b[j] < a[i])) {
            c.push_back(b[j]);                                                                                         // =
            j++;
        } else {                                                                                                       // =
            c.push_back(a[i]);                  
            i++;
            j++;                                                                                                       // =
        }
    }
                                                                                                                       //=
// ========================================================================================================================

    // Removing duplicates from c
    if (!c.empty()) {
        vector<int> result;
        result.push_back(c[0]);
        for (int k = 1; k < c.size(); ++k) {
            if (c[k] != c[k - 1]) {
                result.push_back(c[k]);
            }
        }
        c = result;
    }

    return c;
}


//==============================================Q4)Missing Number==========================================================================================================================================================
==>>> brute firce code 
#include<unordered_map>
class Solution {
public:
    int missingNumber(vector<int>& nums) {
      // find the largest element in the nums
      unordered_map<int, int> visited;
      int largest = INT_MIN;
      for(int i = 0 ; i < nums.size() ; i++) if(nums[i] > largest) largest = nums[i] ;
      for(int i = 0 ; i <= largest ; i++) visited[i] = 1;
      for(int i = 0 ; i< nums.size(); i++) visited[nums[i]] = 0;

      for(auto s : visited){
        if(s.second  == 1){
            return s.first;
        }
      }
     return largest+1;
    }
};

// =====>>>>> method 2 <<<<<============
// better or optimal code
#include<unordered_map>
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int sum = (n*(n+1))/2;
        int currSum = 0;
        for(int i=0;i<n;i++)
            currSum += nums[i];
        return sum-currSum;
    }
};


//================================================Q5)Find The Single Element =======================================================================================================================================
// ==========>>>>>brute code   time complexity : O(N2)  space complexity : #include <bits/stdc++.h>
using namespace std;

int getSingleElement(vector<int> &arr) {
    // Size of the array:
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        int num = arr[i]; // selected element
        int cnt = 0;

        //find the occurrence using linear search:
        for (int j = 0; j < n; j++)   if (arr[j] == num) cnt++;
        if (cnt == 1) return num;
    }
    return -1;
}


//  code space complexity :- O(n) and time complexity :- O(n)   ====================================
#include<vector>
#include<unordered_map>

int getSingleElement(vector<int> &arr){
	// Write your code here.	
	unordered_map<int , int> visited;
	for(int i = 0; i< arr.size() ; i++){
		visited[arr[i]]++;
	}

	for(auto  s : visited){
		if(s.second < 2){
			return s.first;
		}
	};

	return -1;
}
 // ========================>>>>>>>  OPTIMAL CODE <<<<<<=================
  XOR of two same numbers is always 0 i.e. a ^ a = 0. ←Property 1.
  XOR of a number with 0 will result in the number itself i.e. 0 ^ a = a.  ←Property 2
  //====>>> space complexity :- O(1)
  //====>>> time complexity  :- O(n)


  class Solution {
  public:
    int singleNumber(vector<int>& nums) {
        // method 2 
        int xorr = 0;
        for(int i = 0 ; i < nums.size() ; i++){
            xorr = xorr ^ nums[i];
        }
        return xorr;
    }
};



//=============================================== Q6) Product of Array Except Self =================================================================================================================================
//   ======== >>>brute force code <<<========
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n,1);
        int j = 0;
        for (int j = 0; j < n; ++j)
        {
            int index = (j +1 ) % n;
            int sum = 1 ;
            int count = 0;
            while(count < n-1){
             sum = sum * nums[index];
             index = (index + 1) %n;
             count++;
            }
            ans[j] = sum;
            
        }
        return ans;
    }
};
// =========>> More better  <<===================================================
   ==>> average time complexity  :- O(n) but worse time complexity :- O(n*n)
   ==>> space complexity :- O(n)
   class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        
        vector<int> ans;

        int product = 1;
        for (int i : nums) {
            product *= i;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != 0) {
                ans.push_back(product / nums[i]);
            } else {
                int act_product = 1;
                for (int j = 0; j < nums.size(); j++) {
                    if (j != i) {
                        act_product *= nums[j];
                    }
                }
                ans.push_back(act_product);
            }
        }
        return ans;
    }
};

// =====>>>> further optimised this code  <<<<<=================
time complexity :- O(n) and space complexity :- O(n) worse and average time 
=====>>> method of left and right array prodect and handling edges case <<<<<==========
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
    
        vector<int> left(n,1);
        vector<int> right(n,1);

        // left product of the array element 
        // int se hi jo jayega only to problem nahi hoga previous se multiply karna hai only 
        int leftProduct = 1;
        for(int i = 0 ; i < nums.size() ; i++){
            left[i] = leftProduct * nums[i];
            leftProduct = left[i];
        }
        // right product of array element
        int rightproduct = 1;
        for(int i = n-1 ; i>= 0 ; i --){
            right[i] = rightproduct * nums[i];
            rightproduct = right[i];
        }
        
        // Now multiplication of both the array 
        for(int i = 0 ; i < nums.size() ; i++){
            if(i == 0){
                nums[0] = right[1];
            }
            else if(i == n-1){
                nums[n-1] = left[n-2];
            }else{
                nums[i] = left[i-1] * right[i+1];
            }
        }
     return nums;
    }
};
//=======>>>>>> most optimal code  <<===============  
// =====>>>  with the help of DP  <<<=======


// =========================================================== Q7.  Longest Subarray With Sum K  =================================================================================================================
//=====>>> brute force code  << ===============
#include <vector>
using namespace std;

int longestSubarrayWithSumK(vector<int> a, long long k) {
    int largest = 1; // Initialize to 1 to handle the case when the entire array sums up to k
    for (int i = 0; i < a.size(); i++) {
        int sum = 0;
        for (int y = i; y < a.size(); y++) {
            sum += a[y];
            if (sum == k) {
                largest = max(largest, y - i + 1);
            }
        }
    }
    return largest;
}
// ===============>>> Optimal code  <<<<==================
#include <vector>
#include <algorithm> // for max

using namespace std;

int longestSubarrayWithSumK(vector<int> a, long long k) {
    long long sum = 0;
    int right = 0 ; 
    int left = 0;
    int n = a.size();
    int length = 0;
    while(right < n){
        sum = sum + a[right];

        // while(sum > k && left <= right ) // Ensure left <= right when adjusting window size  ====>>> sochna  hai kya ho sakta hai 
        while(sum > k  ) // Ensure left <= right when adjusting window size ===>>>> isse bhi ho jaa rha hai to prblm nahi hai 
        {
            sum = sum - a[left];
            left++;
        }
        if(sum == k ){
            length = max(length , (right -  left + 1));
        }

        right ++;
    }
    return length;
}

// ====>>>> better approach <<======== 










// =======================================================================  Q8)  Two Sum  ===========================================================================
//======>>>>> brute force code  <<<<<========
// complexity :---- O(n2)
string read(int n, vector<int> book, int target)
{
    // brute force code 
    string  s = "NO";
    for(int i = 0 ; i < book.size() ; i++){
        int sum = 0 ; 
        for(int j = i+1 ;  j < book.size() ; j++ ){
            if((book[i] + book[j]) == target){
                s = "YES";
            }
        }
    }

   return s;
}

// ===========>>> better <<<=============
// O(n) ==> Time complexity 
#include <unordered_map>
string read(int n, vector<int> book, int target)
{
   unordered_map <int , int > sum;
   for(int i = 0 ; i < book.size() ; i++){
        int value = book[i];
        sum[value]  = i;
   }
   // now abb differe map me dekhna hai available hai to thik hai nahi to return false

   for(int j = 0 ; j < book.size() ; j++){
       int desiredvalue = target - book[j];
       if(sum.find(desiredvalue) != sum.end()){
              return  "YES";
       }
   }

   return "NO";
}

                                                 //=====>>>>> Leetcode <<<<<<<====   
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
       unordered_map <int , int > sum;
        

       for(int j = 0 ; j < nums.size() ; j++){
       int desiredvalue = target - nums[j];
       if(sum.find(desiredvalue) != sum.end() && sum[desiredvalue] != j){
              return  {sum[desiredvalue] , j};
          }
          sum[nums[j]] = j;   // Alag alag loop me kar rahe the sath me bhi to kar hi sakte hai simple hai 
       }
       return {};  
    }
};
======>>> DRAWBACKS <<<=====
Time Complexity: O(N), where N = size of the array.
Reason: The loop runs N times in the worst case and searching in a hashmap takes O(1) generally. So the time complexity is O(N).

Note: In the worst case(which rarely happens), the unordered_map takes O(N) to find an element. In that case, the time complexity will be O(N2). If we use map instead of unordered_map, the time complexity will be O(N* logN) as the map data structure takes logN time to find an element.

Space Complexity: O(N) as we use the map data structure.

// =====>>> OPTIMISED CODE <<<=======  
//=====>>>>> Two pointer approach  <<<<<======
#include <unordered_map>
string read(int n, vector<int> book, int target)
{
   // OPTIMISED CODE with space complexity O(1)
  
   sort(book.begin() , book.end());
   int start = 0 ;
   int end = n-1;
   int sum = 0;
   while(start < end){
      sum = book[start] + book[end];
      if(sum == target){
          return "YES";
      }
      if(sum > target) end--;
      if(sum < target) start++;
   }
   return "NO";
}

// ===========================================================================Q9  Sort An Array of 0s, 1s and 2s  =====================================================================================================================================
// =====>> OPTIMAL APPROACH ============
#include <bits/stdc++.h> 
//TIME COMPLEXITY :- O(n)
void sortArray(vector<int>& arr, int n)
{
    int count_one = 0;
    int count_two = 0;

    for(int i = 0 ; i < arr.size() ; i++){
       if(arr[i] == 2) count_two ++; 
       if(arr[i] == 1) count_one ++; 
    }
    
    int j = n-1;
    while(j >= 0){
        if(count_two > 0){
            arr[j] = 2;
            count_two--;
        }
        else if(count_one > 0 && count_two == 0){
            arr[j] = 1;
            count_one--;
        }
        else{
            arr[j] = 0 ;

        }
       j--;
    }
}
