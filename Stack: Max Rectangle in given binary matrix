// =========================== GFG ====================================================================
// complexity :- time complexity :- O(n*m) 
//               space complexity :- O(m)
class Solution{
  private :
  
  
   vector<int>nextSmallerElement(int * arr ,int n){
  stack<int>s;
  s.push(-1);
  vector<int>ans(n);
  for(int i = n-1 ; i>= 0 ; i--){
      int curr = arr[i];
    while(s.top()!= -1 && arr[s.top()]>= curr){
      s.pop();
    }
    // index ko push kar dete hai 
     ans[i] = s.top();
     s.push(i);


  }

   return ans;
 }
  
  vector<int>prevSmallerElement(int * arr ,int n){
  stack<int>s;
  s.push(-1);
  vector<int>ans(n);
  for(int i = 0 ; i<n ; i++){
      int curr = arr[i];
    while(s.top()!= -1 && arr[s.top()]>= curr){
      s.pop();
    }
    // index ko push kar dete hai 
     ans[i] = s.top();
     s.push(i);


  }

   return ans;
 }

 
 
 int largestRectangle(int * heights  , int n) {
   // Write your code here.
//   int n = heights.size();
   vector<int> next(n);
   next = nextSmallerElement(heights , n);
   
   vector<int> prev(n);
   prev = prevSmallerElement(heights , n);

   int newarea = INT_MIN;

   for(int i = 0 ; i<n ; i++){
      int l = heights[i];
      if(next[i] == -1){
        next[i] = n;
      }
      int b = next[i]- prev[i] - 1;
      int area = l*b;
      newarea = max(area , newarea); 
   }
  return newarea;
 }
 
 
  public:
    int maxArea(int M[MAX][MAX], int n, int m) {
        // Your code here
    
    int area = largestRectangle(M[0] , m);
   
    for(int i = 1 ; i< n ; i++){
        for(int j = 0 ; j< m ; j++){
            // update karna  hai 
           if(M[i][j] != 0){
               M[i][j] = M[i][j] + M[i-1][j];
           }else{
               M[i][j] = 0;
           }
        }
        int newarea = largestRectangle(M[i] , n);
        area = max(area ,newarea  );
     }
     return area; 
    }
};
