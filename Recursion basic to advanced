// ===============>>>>>> Q1)Find X raised to power N  <<================================
double myPow(double x, int n) {
    if(n == 0){
        return 1;
    }
    if( n > 0 ){
        return  x * myPow(x , n-1);
    }else{
        return 1/x*myPow(x , n+1);
    }
}

//====>>>> optimal code for leetcode <<<<===
class Solution {
public:
    double myPow(double x, int n) {
       // since mangnitude of -ve range of integer is greater than +ve so when we make it negative then it will occur TLE
       long long nn = n;
       if(nn < 0){
        nn =  -1 * nn;
       }
       double ans = 1.0;
       while(nn){
        if(nn % 2 == 1){
            ans = ans * x;
            nn = nn -1;
        }else{
            x = x * x;
            nn = nn/2;
        }
       }
       if(n < 0){
          return 1/ans;
       }
       return ans;
    }
};

// ==================>>>> Q2) Count Good Numbers <<<<============================
// =============>>> imortant question hai <<==============
class Solution {
public:
    long long findpow(long long x, long long n) {
        long long result = 1;
        while (n > 0) {
            if (n % 2 == 1) {
                result = (result * x) % 1000000007; // Modulo to avoid overflow
            }
            x = (x * x) % 1000000007; // Modulo to avoid overflow
            n /= 2;
        }
        return result;
    }
    
    int countGoodNumbers(long long n) {
        long long pp = n / 2;
        long long ep = n - pp;
        
        long long x = findpow(4, pp);
        long long y = findpow(5, ep);
        
        return (x * y) % 1000000007; // Modulo to avoid overflow
    }
};
// Note :- When question is telling you that you have to return in modulous then you should apply as much as you can so that overflow should not be there 
// ================================>>>> Q3) Reverse Stack Using Recursion <<<<==================================== 
#include<bits/stdc++.h>
using namespace std;
 
void reversta(stack<int> &stack , vector<int>& re){
  if(stack.empty()){
        return ;
    }

    int top  = stack.top();
    re.push_back(top);
    stack.pop();
   reversta(stack , re);
}
void reverseStack(stack<int> &stack) {
  vector<int>re;
   reversta(stack , re);
    for(int i = 0 ; i < re.size() ; i++){
        stack.push(re[i]);
    }
 
}
// ==============>>> Recursive approach <<<======================
void insertAtbottom(stack<int> &stack , int ans){

if(stack.empty()){
    stack.push(ans);
    return ;
}

   int top = stack.top();
   stack.pop();

   insertAtbottom(stack , ans);
   stack.push(top);
}



void reverseStack(stack<int> &stack) {
    // Write your code here

  if(stack.empty()){

     return ;
  }

  int ans = stack.top();
  stack.pop();
  
  reverseStack(stack);

  // Insert at the bottom 
  insertAtbottom(stack ,ans);

 

}

====================>>>>> Q4)  Sort Stack <<<<==============================================
#include <stack>
using namespace std;

void insertElement(stack<int> &s, int top) {
    if (s.empty() || top > s.top()) {
        s.push(top);
        return;
    }

    int temp = s.top();
    s.pop();
    insertElement(s, top);
    s.push(temp);
}

stack<int> sortStack(stack<int> &s) {
    if (s.empty()) {
        return s;
    }

    int top = s.top();
    s.pop();
    sortStack(s);
    insertElement(s, top);

    return s;
}


// ==============================================

