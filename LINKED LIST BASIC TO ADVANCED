//=====================================>> Q1). Delete node in Doubly Linked List  <<=======================================================================================================

class Solution
{
public:
    Node *deleteNode(Node *head_ref, int x)
    {
        //Your code here
        Node *head = head_ref;
        if (head == NULL)
        {
            return NULL;
        }

        if (x == 1)
        {
            if (head->next != NULL)
            {
                head_ref = head_ref->next;
                head_ref->prev = NULL;
            }
            else
            {
                // If x is 1 and there is only one node, set head_ref to NULL
                delete head;
                return NULL;
            }
        }

        int count = 1;

        while (head->next != NULL && x != count)
        {
            count = count + 1;
            head = head->next;
        }

        // head pointer wahi value ko point kar raha hai
        Node *previous = NULL;
        Node *nextnode = NULL;

        if (count == x)
        {
            // delete karna hai
            previous = head->prev;
            nextnode = head->next;
            if (previous != NULL)
                previous->next = nextnode;

            // Check if it is not the last node
            if (nextnode != NULL)
                nextnode->prev = previous;

            delete head;
        }

        return head_ref;
    }
};

// ---------------------------------------Q2) CYCLE DETECTION POINT ------------------------------------------------------------------------------------------

Node *firstNode(Node *head)
{

    if(head == NULL || head->next == NULL){
        return NULL;
    }
    Node * slow = head;
    Node * fast = head;
    Node * p1 = NULL;

    

    while(fast != NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;

        // meeting point of the slow and fast 
        if(slow == fast){
            p1 = slow;
            break ;
        }
    }
    if(p1 == NULL){
        return NULL;
    }
    slow = head;
    while(slow != p1 && slow != NULL && fast != NULL){
        slow = slow->next;
        p1 = p1->next;
    }
    
    return p1;

}

// -----------------------------------------------Q3) Find the length of the loop ------------------------------------------------------------------------------------------------------------------------------------------------------------------

int lengthOfLoop(Node *head) {
    Node * slow = head;
    Node * fast = head;
    int count = 1;
    Node * p1 = NULL;

    while(fast != NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;

        if(slow == fast){
            p1 = slow;
            break;
        }
    }
    if(p1 == NULL){
        return 0;
    }
    
    slow = slow->next;
    while(slow != fast){
        slow = slow->next;
        count++;
    }
    
    return count;
}
// -------------------------------------------------------Q4) check the  Palindrome ---------------------------------------------------------------------------------------------------------------------------------------------
// method of splitting 
bool isPalindrome(Node *head)
{
   Node * slow = head ;
   Node * fast = head;
   Node * start = head;
   Node * previous  = NULL;
     while(fast != NULL && fast->next != NULL){
       slow = slow->next;
       fast = fast->next->next;
     }
   
   Node * temp = slow->next;
   slow->next  = NULL;

   // yaha par wo galti nahi karna hai ki temp->next != NULL ye condition nahi dalna hai samjhaa bhi bakki sab sahi hai 
   while(temp != NULL ){
       Node * nextNode = temp->next;
       temp->next = previous;
       previous = temp;
       temp = nextNode;
   }

   while(previous != NULL &&  start != NULL){

       if(previous->data != start->data){
           return false;
       }

       previous = previous->next;
       start = start->next;

       
   }
   
  
   
 return true ;
}

// ---------------------------------------------------Q5)Segregate Even And Odd Nodes In a Linked List   ----------------------------------------------------------------------------------------------
// brute force code 
Node* segregateEvenOdd(Node* head)
{
    // Write your code here
    vector<int> even;
    vector<int> odd;
    Node * start = head;
  
    while(start != NULL){
        if(start->data % 2 == 0){
            even.push_back(start->data);
        }else{
            odd.push_back(start->data);
        }
       start = start->next;
    }

    Node * evenNode = new Node(even[0]);
    Node * startevenNode = evenNode;
    for(int i = 1 ;i < even.size() ; i++){
        Node * temp = new Node(even[i]);
        evenNode->next = temp;
        evenNode = temp;
    }

    Node * oddNode = new Node(odd[0]);
    Node * startoddNode = oddNode;
    for(int i = 1 ;i< odd.size() ; i++){
        Node * temp = new Node(odd[i]);
        oddNode->next = temp;
        oddNode = temp;
    }

    evenNode->next = startoddNode;
    
    return startevenNode;
}
// ==--------------------------------------------------------
