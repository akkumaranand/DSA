//=====================================>> Q1). Delete node in Doubly Linked List  <<=======================================================================================================

class Solution
{
public:
    Node *deleteNode(Node *head_ref, int x)
    {
        //Your code here
        Node *head = head_ref;
        if (head == NULL)
        {
            return NULL;
        }

        if (x == 1)
        {
            if (head->next != NULL)
            {
                head_ref = head_ref->next;
                head_ref->prev = NULL;
            }
            else
            {
                // If x is 1 and there is only one node, set head_ref to NULL
                delete head;
                return NULL;
            }
        }

        int count = 1;

        while (head->next != NULL && x != count)
        {
            count = count + 1;
            head = head->next;
        }

        // head pointer wahi value ko point kar raha hai
        Node *previous = NULL;
        Node *nextnode = NULL;

        if (count == x)
        {
            // delete karna hai
            previous = head->prev;
            nextnode = head->next;
            if (previous != NULL)
                previous->next = nextnode;

            // Check if it is not the last node
            if (nextnode != NULL)
                nextnode->prev = previous;

            delete head;
        }

        return head_ref;
    }
};

// ---------------------------------------Q2) CYCLE DETECTION POINT ------------------------------------------------------------------------------------------

Node *firstNode(Node *head)
{

    if(head == NULL || head->next == NULL){
        return NULL;
    }
    Node * slow = head;
    Node * fast = head;
    Node * p1 = NULL;

    

    while(fast != NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;

        // meeting point of the slow and fast 
        if(slow == fast){
            p1 = slow;
            break ;
        }
    }
    if(p1 == NULL){
        return NULL;
    }
    slow = head;
    while(slow != p1 && slow != NULL && fast != NULL){
        slow = slow->next;
        p1 = p1->next;
    }
    
    return p1;

}

// -----------------------------------------------Q3) Find the length of the loop ------------------------------------------------------------------------------------------------------------------------------------------------------------------

int lengthOfLoop(Node *head) {
    Node * slow = head;
    Node * fast = head;
    int count = 1;
    Node * p1 = NULL;

    while(fast != NULL && fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;

        if(slow == fast){
            p1 = slow;
            break;
        }
    }
    if(p1 == NULL){
        return 0;
    }
    
    slow = slow->next;
    while(slow != fast){
        slow = slow->next;
        count++;
    }
    
    return count;
}
// -------------------------------------------------------Q4) check the  Palindrome ---------------------------------------------------------------------------------------------------------------------------------------------
// method of splitting 
bool isPalindrome(Node *head)
{
   Node * slow = head ;
   Node * fast = head;
   Node * start = head;
   Node * previous  = NULL;
     while(fast != NULL && fast->next != NULL){
       slow = slow->next;
       fast = fast->next->next;
     }
   
   Node * temp = slow->next;
   slow->next  = NULL;

   // yaha par wo galti nahi karna hai ki temp->next != NULL ye condition nahi dalna hai samjhaa bhi bakki sab sahi hai 
   while(temp != NULL ){
       Node * nextNode = temp->next;
       temp->next = previous;
       previous = temp;
       temp = nextNode;
   }

   while(previous != NULL &&  start != NULL){

       if(previous->data != start->data){
           return false;
       }

       previous = previous->next;
       start = start->next;

       
   }
   
  
   
 return true ;
}

// ---------------------------------------------------Q5)Segregate Even And Odd Nodes In a Linked List   ----------------------------------------------------------------------------------------------
// brute force code 
Node* segregateEvenOdd(Node* head)
{
    // Write your code here
    vector<int> even;
    vector<int> odd;
    Node * start = head;
  
    while(start != NULL){
        if(start->data % 2 == 0){
            even.push_back(start->data);
        }else{
            odd.push_back(start->data);
        }
       start = start->next;
    }

    Node * evenNode = new Node(even[0]);
    Node * startevenNode = evenNode;
    for(int i = 1 ;i < even.size() ; i++){
        Node * temp = new Node(even[i]);
        evenNode->next = temp;
        evenNode = temp;
    }

    Node * oddNode = new Node(odd[0]);
    Node * startoddNode = oddNode;
    for(int i = 1 ;i< odd.size() ; i++){
        Node * temp = new Node(odd[i]);
        oddNode->next = temp;
        oddNode = temp;
    }

    evenNode->next = startoddNode;
    
    return startevenNode;
}
//======= optimal code ======
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        
        if(head == NULL || head->next == NULL || head->next->next == NULL){
            return head;
        }

        ListNode * oddNode = head;
        ListNode * newoddNode = head;
        ListNode * evenNode = head->next;
        ListNode * startevenNode = head->next;

        while(evenNode != NULL && evenNode->next != NULL ){
            oddNode->next = oddNode->next->next;
            oddNode = oddNode->next;

            evenNode->next = evenNode->next->next;
            evenNode = evenNode->next;
        }

        oddNode->next = startevenNode;
      
      return newoddNode;
    }
};
// ==-------------------------------------------------------- Q6 ) Merge two sorted linked list ===================================================================
// optimal code =====
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
       // concept of the dummy Node 
       // initialise the node 
       ListNode * dummyNode = new ListNode(-1);
       ListNode * temp = dummyNode;
       ListNode * t1 = list1;
       ListNode * t2 = list2;

       // merge with equall node 
       while(t1 != NULL && t2 != NULL){
           if(t1->val < t2->val){
               temp->next = t1;
               temp = t1;
               t1 = t1->next;
           }
           else{
               temp->next = t2;
               temp = t2;
               t2 = t2->next;
           }
       }

      // link the rest of the code 
      if(t1){
          temp->next = t1;
       }else{
           temp->next = t2;
       }

      return dummyNode->next;
    }
};
// ============================================================= Q6) SORT THE LINKED LIST IN O(1) SPACE COMPLEXITY ================================
Node * Mergetwolinkedlist(Node * & list1  , Node * & list2){
    // dummy node concept hai 
    Node * dummyNode = new Node(-1);
    Node * temp = dummyNode;
    Node * t1 = list1;
    Node * t2 = list2;

    // merge two equal node 
    while(t1 != NULL && t2 != NULL){
        if(t1->data < t2->data ){
            temp->next = t1;
            temp = t1;
            t1 = t1->next;
        }else{
            temp->next = t2;
            temp = t2;
            t2 = t2->next;
        }
    }
    
    if(t2){
        temp->next = t2;
    }else{
        temp->next = t1;
    }

    return dummyNode->next;
}
Node* sortList(Node* head){
   // merge sort apply karna hai basically in linked list
   if(head == NULL || head->next == NULL){
       return head;
   }

   Node * start = head;
   
   // middle element me 
   Node * slow = head;
   Node * fast = head ->next;

   while(fast != NULL && fast->next != NULL){
       slow = slow->next;
       fast = fast->next->next;
   } 

   Node * L2 = slow->next;
   slow->next = NULL;

   Node * left =  sortList(start);
   Node * right = sortList(L2);


   return Mergetwolinkedlist(left , right);

}

// ==========================================================================================================================================================================
