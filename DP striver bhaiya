==============>>> Q1) Fibbonacci series <<=================
// ======>> brute force approach <<===
class Solution {
public:
    
    int fib(int n) {
       if(n <= 0 || n == 1){
        return n;
       } 

       return fib(n-1) + fib(n-2);
    }
};

// =====>>> optimisation <<===== 
//======>>>> mmemoization <<====
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
        if(n<=0 || n == 1){
            return n;
        } 

        if(dp[n] != -1){
            return dp[n];
        }
        
        dp[n] = findfibb(n-1 , dp) + findfibb(n-2 , dp);

        return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 , -1);
       int ans = findfibb(n , dp);
       return ans;
    }
};
===>> time complexity ==>> O(n)
===>> space complexity ==>> O(N)

// =======>>>>> Tabulation (bottom up) <<<==========
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
       // ====>> bottom up approach <<===
       // initialization hota hai 
       if(n == 0 || n == 1){
        return n;
       }
       dp[0] = 0;
       dp[1] = 1;

       // code 
       
        for(int i = 2 ; i <=n ; i++){
         dp[i] = dp[i-1] + dp[i-2];
       }
       
      

       return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 );
       int ans = findfibb(n , dp);
       return ans;
    }
};
============>>>> important to understand <<<================
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
       // ====>> bottom up approach <<===
       // initialization hota hai 
       // when   n = 0 then why we are assigning dp[1] == >> leading overflow because at that time size is only one of for zero only
       dp[0] = 0;
       if(n > 0){
         dp[1] = 1;
       }
       

       // code 
       
        for(int i = 2 ; i <=n ; i++){
         dp[i] = dp[i-1] + dp[i-2];
       }
       
      

       return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 );
       int ans = findfibb(n , dp);
       return ans;
    }
};
// ==========>>> space optimisation <<<============
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        int prev2 = 0;
        int prev1 = 1;
        int current;

        for (int i = 2; i <= n; ++i) {
            current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }

        return current;
    }
};


// ============================================================>>> Q2) Climbing Stairs  <<=====================================================
// ===========>>> similar Question as fibbonacci series no need to further optimisation  <<<<<============
class Solution {
public:
    int findclimbStairs(int n , vector<int> & dp){
        if(n == 1 || n == 2){
            return n;
        }
        if(dp[n] != -1){
            return dp[n];
        }
       
        dp[n] = findclimbStairs(n-1 , dp) + findclimbStairs(n-2 , dp);
        return dp[n];
    }
    int climbStairs(int n) {
        // memoization solution
        vector<int>dp(n+1 , -1);
        int ans = findclimbStairs(n, dp);
        return ans;
    }
};

//============>> optimised <<<<===
class Solution {
public:
    int findclimbStairs(int n , vector<int> & dp){
        if(n == 0 || n == 1){
            return 1;
        }
        if(dp[n] != -1){
            return dp[n];
        }
        int left = findclimbStairs(n-2 , dp);
        int right = findclimbStairs(n-1 , dp); 
        
        // count all possible ways 
        dp[n] = left + right ;
        return dp[n];
    }
    int climbStairs(int n) {
        // memoization solution
        vector<int>dp(n+1 , -1);
        int ans = findclimbStairs(n, dp);
        return ans;
    }
};

//==================>>> Q3) Frog jump <<<================
=====>>>> brute force approach <<===
#include <bits/stdc++.h> 
int findmin(int index , vector<int> & heights){
    if(index == 0){
        return 0;
    }
    
    // jump from index to index -1 energy lost 
    int left = findmin(index - 1 , heights) + abs(heights[index] - heights[index-1]);
    // to avoid negative
    int right = INT_MAX;
    if(index > 1){
         right = findmin(index - 2 , heights) + abs(heights[index] - heights[index-2]);
    }

    return min(left , right);
}
int frogJump(int n, vector<int> &heights)
{ 
    
   int ans =  findmin(n-1 , heights);
   return ans;
}

//========>>> TOP-DOWN approach <<<============
#include <bits/stdc++.h> 
int findmin(int index , vector<int> & heights , vector<int> &dp){
    if(index == 0){
        return 0;
    }
    
    if(dp[index]  != -1){
        return dp[index];
    }
    
    // jump from index to index -1 energy lost 
    int left = findmin(index - 1 , heights ,dp) + abs(heights[index] - heights[index-1] );
    // to avoid negative
    int right = INT_MAX;
    if(index > 1){
         right = findmin(index - 2 , heights , dp) + abs(heights[index] - heights[index-2]);
    }
    
    dp[index] = min(left , right);
    return dp[index];
}
int frogJump(int n, vector<int> &heights)
{   // using momoization 
    vector<int>dp(n+1 , -1);   // you can take n size but for safe side take n+ 1 
   int ans =  findmin(n-1 , heights , dp);
   return ans;
}
// ===========>>>  bottom Up <<<==========
#include <bits/stdc++.h>
using namespace std;

int frogJump(int n, vector<int> &heights) {
    // Create a dp array to store the minimum energy for each stone
    vector<int> dp(n, 0);

    // Base cases
    dp[0] = 0; // Energy needed to stay on the first stone is 0
     // base condition ko modifies bhi kar sakte hai 
    for (int i = 1; i < n; ++i) {
        // Calculate the cost to jump from the previous stone
        int jumpOneStep = dp[i - 1] + abs(heights[i] - heights[i - 1]);
        
        // Initialize the cost to jump from two stones before with a large value
        int jumpTwoSteps = INT_MAX;

        // Calculate the cost to jump from two stones before if possible
        if (i > 1) {
            jumpTwoSteps = dp[i - 2] + abs(heights[i] - heights[i - 2]);
        }

        // The minimum energy to reach stone i
        dp[i] = min(jumpOneStep, jumpTwoSteps);
    }

    // The minimum energy to reach the last stone
    return dp[n - 1];
}


// =================>>>> space optimisation <<<================
#include <bits/stdc++.h>
using namespace std;

int frogJump(int n, vector<int> &heights) {
    if (n == 1) return 0;

    int prev2 = 0;
    int prev1 = abs(heights[1] - heights[0]);

    for (int i = 2; i < n; ++i) {
        int current = min(prev1 + abs(heights[i] - heights[i - 1]), prev2 + abs(heights[i] - heights[i - 2]));
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}


// ======================================>>>> Q4) Frog Jump with k distances(DP-4) <<<======================
// =============>>> link for the code ==>> https://www.geeksforgeeks.org/problems/minimal-cost/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=minimal-cost
// ================>>> Very very important Question  hai <<<======================
// =======>>>> For further optimisation you can visit to previous problem exact similiar to this <<<==================
space complexity :- O(n)
Time complexity :- O(n*k)
//class Solution {
public:
    int findmincost(int index, vector<int> &height, int k, vector<int> &dp) {
        // Base case
        if (index == 0) {
            return 0;
        }
        
        // Memoization check
        if (dp[index] != -1) {
            return dp[index];
        }

        int minii = INT_MAX;
        for (int s = 1; s <= k; ++s) {
            if (index - s >= 0) {
                int jumpCost = findmincost(index - s, height, k, dp) + abs(height[index] - height[index - s]);
                minii = min(minii, jumpCost);
            }
        }
        
        dp[index] = minii;
        return dp[index];
    }

    int minimizeCost(vector<int>& height, int n, int k) {
        vector<int> dp(n, -1);
        return findmincost(n - 1, height, k, dp);
    }
};


// =======================>>>> Q5)Maximum sum of non-adjacent elements (DP 5) <<======================
//========>>> Ek dry run kar ke dekh lena waise yaha tak to asaan hi hai ====>>> jo index ko liye usko add kiye adjacent nahi le sakte to siimply index-2 ko function call kar diye agar pick nahi kiye to simply usko index-1 ko call 
//=====>>> brute force approch <<==========
class Solution {
public:
    int findrob(int index , vector<int>&nums){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          if(index < 0) return 0;

        // ====>>> main code <<<=====
        int pick = nums[index] + findrob(index - 2  , nums);    // qki adjacent nahi hona chahiye isliye -2 liya hu  
        
        // pick nahi kiye
        int donotpick =  0 + findrob(index-1 , nums);

        return max(pick , donotpick);
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int ans = findrob(index , nums);
        return ans;

    } 
            
};

// =============>>> Memoization method <<<<============
class Solution {
public:
    int findrob(int index , vector<int>&nums , vector<int> &dp){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          if(index < 0) return 0;
         
         if(dp[index] != -1){
            return dp[index];
         }
        // ====>>> main code <<<=====
        int pick = nums[index] + findrob(index - 2  , nums , dp);    // qki adjacent nahi hona chahiye isliye -2 liya hu  
        
        // pick nahi kiye
        int donotpick =  0 + findrob(index-1 , nums , dp);

        dp[index] = max(pick , donotpick);

        return dp[index];
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int n = nums.size();
        vector<int>dp(n , -1);
        int ans = findrob(index , nums , dp);
        return ans;

    } 
            
};
// ==============>>>> bottom-up or tabulation appoach <<<<============
class Solution {
public:
    int findrob(int index , vector<int>&nums , vector<int> &dp){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          
          dp[0] = nums[0];

          
          for(int i = 1 ; i <= index ; i++){
            // i == 1 to return karoge ya kuch to hoga na 
            int pick = nums[i]; 
            if(i>1){
               pick = nums[i] + dp[i-2];
            }
            int donotpick = 0 + dp[i-1];
             dp[i] = max(pick , donotpick);
          }
          
          return dp[index];
       
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int n = nums.size();
        vector<int>dp(n );
        int ans = findrob(index , nums , dp);
        return ans;

    } 
            
};
====>>>> Another way previous one is more better than curr
class Solution {
public:
    int findrob(int index, vector<int>& nums, vector<int>& dp) {
        // Base cases
        if (index == 0) return nums[index];
        if (index == 1) return max(nums[0], nums[1]);

        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for (int i = 2; i <= index; i++) {
            int pick = nums[i] + dp[i - 2];
            int donotpick = dp[i - 1];
            dp[i] = max(pick, donotpick);
        }

        return dp[index];
    }

    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        vector<int> dp(n);
        int ans = findrob(n - 1, nums, dp);
        return ans;
    }
};

// ==============>>>> space optimisation <<<===============
class Solution {
public:
    int findrob(int index , vector<int>&nums , vector<int> &dp){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          
           int prev = nums[0];
           int prev2 = 0;

          
          for(int i = 1 ; i <= index ; i++){
            // i == 1 to return karoge ya kuch to hoga na 
            int pick = nums[i]; 
            if(i>1){
               pick = nums[i] + prev2;
            }
            int donotpick = 0 + prev;
             int curr = max(pick , donotpick);
             prev2 = prev;
             prev = curr;
          }
          
          return prev;
       
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int n = nums.size();
        vector<int>dp(n );
        int ans = findrob(index , nums , dp);
        return ans;

    } 
            
};


/// ===============>>>> Q6)House Robber (DP 6) <<<===============
===============>>>>> VERY IMPORTATN QUESTION HAI <<<<<===========
class Solution {
public:
    int findrobcicle(int index, vector<int>& nums, vector<int>& dp) {
        if (index == 0) return nums[0];
        if (index < 0) return 0;

        if (dp[index] != -1) return dp[index];

        int pick = nums[index] + findrobcicle(index - 2, nums, dp);
        int dontpick = findrobcicle(index - 1, nums, dp);

        dp[index] = max(pick, dontpick);
        return dp[index];
    }

    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];

        vector<int> dp1(n, -1);
        vector<int> dp2(n, -1);

        // MOST IMPORTANT PART OF THE CODE ==>>> must know how it is working
        vector<int> temp1(nums.begin(), nums.end() - 1); // Exclude last house
        vector<int> temp2(nums.begin() + 1, nums.end()); // Exclude first house

        int rob1 = findrobcicle(n - 2, temp1, dp1); // n - 2 because last index in temp1 is n-2
        int rob2 = findrobcicle(n - 2, temp2, dp2); // n - 2 because last index in temp2 is n-2

        return max(rob1, rob2);
    }
};

// =======================>>>> Q7) Geek's Training or 	Ninja's Training (DP 7)   <<<=========================
// =================>>> Very very important Question hai must remember type question <<<===========
==>>> Abb sach me majja anne laggga hai code karne me bahut majja aa raaha hai <<<============
  public:
    int findmaximumPoints(int index , int last , vector<vector<int>>&points , vector<vector<int>>&dp){
        // very very important Question to understant in better way
        // base case hai 
        if(index == 0){
            int maxi = 0;
            for(int i = 0 ; i < points[0].size(); i++){
                if(i != last){
                    maxi = max(maxi , points[0][i]);
                }
            }
            return maxi;
        }
        
        if(dp[index][last] != -1){
            return dp[index][last];
        }
        
        // ===>>> jab choice karna hai 3 me ek then take loop check all the possible way
        int maxi =0;
        for(int i = 0 ; i <3 ; i++){
            if(last != i){
                int temp =  points[index][i] +  findmaximumPoints(index - 1 , i , points , dp);
                maxi = max(maxi , temp);
            }
        }
        dp[index][last] = maxi;
        return  dp[index][last];
    }
    int maximumPoints(vector<vector<int>>& points, int n) {
       // first we have to think of the index and if neccesary then take one variable  for next 
       int last = points[0].size();   // jaruri nahi yahi initialise karo last = -1 kar sakte hai 
       //applying dp
       vector<vector<int>>dp(n , vector<int>(last , -1));
       int ans =  findmaximumPoints(n-1 , last  , points , dp);

       return ans;
    }
};

// ============================>>> more better way <<==

#include <bits/stdc++.h>
using namespace std;

// Recursive function to calculate the maximum points for the ninja training
int f(int day, int last, vector<vector<int>> &points, vector<vector<int>> &dp) {
  // If the result for this day and last activity is already calculated, return it
  if (dp[day][last] != -1) return dp[day][last];

  // Base case: When we reach the first day (day == 0)
  if (day == 0) {
    int maxi = 0;
    // Calculate the maximum points for the first day by choosing an activity
    // different from the last one
    for (int i = 0; i <= 2; i++) {
      if (i != last)
        maxi = max(maxi, points[0][i]);
    }
    // Store the result in dp array and return it
    return dp[day][last] = maxi;
  }

  int maxi = 0;
  // Iterate through the activities for the current day
  for (int i = 0; i <= 2; i++) {
    if (i != last) {
      // Calculate the points for the current activity and add it to the
      // maximum points obtained so far (recursively calculated)
      int activity = points[day][i] + f(day - 1, i, points, dp);
      maxi = max(maxi, activity);
    }
  }

  // Store the result in dp array and return it
  return dp[day][last] = maxi;
}

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>> &points) {
  // Create a memoization table (dp) to store intermediate results
  vector<vector<int>> dp(n, vector<int>(4, -1));
  // Start the recursive calculation from the last day with no previous activity
  return f(n - 1, 3, points, dp);
}

// ============>>> Tabulation method <<<===============
// ==============>>>> 2D dp me initilaise base condition ko acche se karna hota hai to dhayan me rakhan 
#include <bits/stdc++.h>
using namespace std;

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>>& points) {
  // Create a 2D DP (Dynamic Programming) table to store the maximum points
  // dp[i][j] represents the maximum points at day i, considering the last activity as j
  vector<vector<int>> dp(n, vector<int>(4, 0));

  // Initialize the DP table for the first day (day 0)
  dp[0][0] = max(points[0][1], points[0][2]);
  dp[0][1] = max(points[0][0], points[0][2]);
  dp[0][2] = max(points[0][0], points[0][1]);
  dp[0][3] = max(points[0][0], max(points[0][1], points[0][2]));

  // Iterate through the days starting from day 1
  for (int day = 1; day < n; day++) {
    for (int last = 0; last < 4; last++) {
      dp[day][last] = 0;
      // Iterate through the tasks for the current day
      for (int task = 0; task <= 2; task++) {
        if (task != last) {
          // Calculate the points for the current activity and add it to the
          // maximum points obtained on the previous day (recursively calculated)
          int activity = points[day][task] + dp[day - 1][task];
          // Update the maximum points for the current day and last activity
          dp[day][last] = max(dp[day][last], activity);
        }
      }
    }
  }

  // The maximum points for the last day with any activity can be found in dp[n-1][3]
  return dp[n - 1][3];
}

// ======================>>>>>>>>>>Q8)Grid Unique Paths : DP on Grids (DP8)   <<<<<==========================================
//====>>> brute force approach <<<===
class Solution {
public:
    int finduniquepaths(int down , int  right ){
        if(down == 0 && right == 0){
            return 1;
        }
        if (down < 0 || right < 0) {
            return 0;
        }

        int dn = finduniquepaths(down -1 , right);
        int rt = finduniquepaths(down , right -1);

        return dn + rt;
    }
    int uniquePaths(int m, int n) {
        int ans = finduniquepaths(m-1 , n-1);
        return ans;
    }
};

// ===========>>> memoization <<<===============
#include <bits/stdc++.h>
using namespace std;

// Recursive function to count the number of ways to reach (i, j) from (0, 0)
// in a grid of size m x n
int countWaysUtil(int i, int j, vector<vector<int>>& dp) {
    // Base case: If we reach the top-left corner (0, 0), there is one way.
    if (i == 0 && j == 0)
        return 1;

    // If we go out of bounds or reach a blocked cell, there are no ways.
    if (i < 0 || j < 0)
        return 0;

    // If we have already computed the number of ways for this cell, return it.
    if (dp[i][j] != -1)
        return dp[i][j];

    // Calculate the number of ways by moving up and left recursively.
    int up = countWaysUtil(i - 1, j, dp);
    int left = countWaysUtil(i, j - 1, dp);

    // Store the result in the dp table and return it.
    return dp[i][j] = up + left;
}


// ===========>>>  Tabulation <<<======================

#include <bits/stdc++.h>
using namespace std;

// Function to count the number of ways to reach the bottom-right cell (m-1, n-1)
// from the top-left cell (0, 0) in a grid of size m x n
int countWaysUtil(int m, int n, vector<vector<int>>& dp) {
    // Loop through the grid using two nested loops
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // Base condition: If we are at the top-left cell (0, 0), there is one way.
            if (i == 0 && j == 0) {
                dp[i][j] = 1;
                continue; // Skip the rest of the loop and continue with the next iteration.
            }

            // Initialize variables to store the number of ways from the cell above (up) and left (left).
            int up = 0;
            int left = 0;

            // If we are not at the first row (i > 0), update 'up' with the value from the cell above.
            if (i > 0)
                up = dp[i - 1][j];

            // If we are not at the first column (j > 0), update 'left' with the value from the cell to the left.
            if (j > 0)
                left = dp[i][j - 1];

            // Calculate the number of ways to reach the current cell by adding 'up' and 'left'.
            dp[i][j] = up + left;
        }
    }

    // The result is stored in the bottom-right cell (m-1, n-1).
    return dp[m - 1][n - 1];
}

// ====>> space optimisation will be done after coding round or when i will have time <<<=====
#include <bits/stdc++.h>
using namespace std;

// Function to count the number of ways to reach the bottom-right cell (m-1, n-1)
// from the top-left cell (0, 0) in a grid of size m x n
int countWays(int m, int n) {
    // Create a vector to represent the previous row of the grid.
    vector<int> prev(n, 0);

    // Iterate through the rows of the grid.
    for (int i = 0; i < m; i++) {
        // Create a temporary vector to represent the current row.
        vector<int> temp(n, 0);

        // Iterate through the columns of the grid.
        for (int j = 0; j < n; j++) {
            // Base case: If we are at the top-left cell (0, 0), there is one way.
            if (i == 0 && j == 0) {
                temp[j] = 1;
                continue;
            }

            // Initialize variables to store the number of ways from the cell above (up) and left (left).
            int up = 0;
            int left = 0;

            // If we are not at the first row (i > 0), update 'up' with the value from the previous row.
            if (i > 0)
                up = prev[j];

            // If we are not at the first column (j > 0), update 'left' with the value from the current row.
            if (j > 0)
                left = temp[j - 1];

            // Calculate the number of ways to reach the current cell by adding 'up' and 'left'.
            temp[j] = up + left;
        }

        // Update the previous row with the values calculated for the current row.
        prev = temp;
    }

    // The result is stored in the last cell of the previous row (n-1).
    return prev[n - 1];
}


// ==========================>>>> Q9) Grid Unique Paths 2 (DP 9)  <<<=============================================

class Solution {
public:
    int  finduniquepathwithobstacle(int i , int j , vector<vector<int>>& obstacleGrid , vector<vector<int>> &dp ){
        if(i == 0  && j == 0 && obstacleGrid[i][j] != 1){
            return dp[i][j] = 1;
        }
        if(i < 0 || j < 0){
            return 0;
        }
        if(obstacleGrid[i][j] == 1){
            return 0;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }

        int up = finduniquepathwithobstacle(i-1 , j , obstacleGrid , dp );
        int left = finduniquepathwithobstacle(i , j-1 , obstacleGrid  , dp);
        dp[i][j] = up + left;
        return dp[i][j];
    }
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(n == 0 && m == 0){
            return 0;
        }
        vector<vector<int>>dp(m , vector<int>(n , -1));
        int ans =  finduniquepathwithobstacle(m-1 , n-1 , obstacleGrid , dp);
        return ans;
    }
};

============>>> ye bhi dekh lena time mile to same hi hai <<<======
int mazeObstaclesUtil(int i, int j, vector<vector<int>> &maze, vector<vector<int>> &dp) {
    // Base cases
    if (i > 0 && j > 0 && maze[i][j] == -1) return 0; // If there's an obstacle at (i, j), return 0
    if (i == 0 && j == 0) return 1; // If we reach the destination (0, 0), return 1
    if (i < 0 || j < 0) return 0; // If we go out of bounds, return 0
    if (dp[i][j] != -1) return dp[i][j]; // If the result is already computed, return it

    // Recursive calls to explore paths from (i, j) to (0, 0)
    int up = mazeObstaclesUtil(i - 1, j, maze, dp);
    int left = mazeObstaclesUtil(i, j - 1, maze, dp);

    // Store the result in the DP table and return it
    return dp[i][j] = up + left;
}

// Main function to count paths with obstacles in a maze
int mazeObstacles(int n, int m, vector<vector<int>> &maze) {
    vector<vector<int>> dp(n, vector<int>(m, -1)); // DP table to memoize results
    return mazeObstaclesUtil(n - 1, m - 1, maze, dp); // Start from the bottom-right corner
}






// =========================>>> Q10 )Minimum path sum in Grid (DP 10) <<===========
===============>>>> must know the some edge case where it can fails 
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int findMinPathSum(int i, int j, vector<vector<int>>& grid, vector<vector<long>>& dp) {
        if (i == 0 && j == 0) {
            return grid[0][0];
        }

        // Boundary check
        if (i < 0 || j < 0) {
            return INT_MAX; // Out of bounds
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        long left = INT_MAX, up = INT_MAX;

        if (j > 0) {
            left = grid[i][j] + findMinPathSum(i, j - 1, grid, dp);
        }
        if (i > 0) {
            up = grid[i][j] + findMinPathSum(i - 1, j, grid, dp);
        }

        dp[i][j] = min(left, up);
        return dp[i][j];
    }

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<long>> dp(m, vector<long>(n, -1));
        return findMinPathSum(m - 1, n - 1, grid, dp);
    }
};
=====>>> tabulation <<===========
#include <bits/stdc++.h>
using namespace std;

// Function to find the minimum sum path from (0, 0) to (n-1, m-1) in the matrix
int minSumPath(int n, int m, vector<vector<int>> &matrix) {
    vector<vector<int>> dp(n, vector<int>(m, 0)); // Initialize a DP table to store minimum path sums

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0)
                dp[i][j] = matrix[i][j]; // If we are at the top-left corner, the minimum path sum is the value at (0, 0)
            else {
                // Calculate the minimum path sum considering moving up and moving left
                int up = matrix[i][j];
                if (i > 0)
                    up += dp[i - 1][j]; // Include the minimum path sum from above
                else
                    up += 1e9; // A large value if moving up is not possible (out of bounds)

                int left = matrix[i][j];
                if (j > 0)
                    left += dp[i][j - 1]; // Include the minimum path sum from the left
                else
                    left += 1e9; // A large value if moving left is not possible (out of bounds)

                // Store the minimum path sum in dp[i][j]
                dp[i][j] = min(up, left);
            }
        }
    }

    // The final result is stored in dp[n-1][m-1], which represents the destination
    return dp[n - 1][m - 1];
}


// =====================>>>> Q11)Minimum path sum in Triangular Grid (DP 11)  <<==========================
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int findmin(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp) {
        int m = triangle.size();
        if (i == m - 1) return triangle[m - 1][j];
        
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        
        // down 
        int down = triangle[i][j] + findmin(i + 1, j, triangle, dp);
        
        // diagonal 
        int diagonal = triangle[i][j] + findmin(i + 1, j + 1, triangle, dp);
        
        dp[i][j] = min(down, diagonal);
        return dp[i][j];
    }
    
    int minimumTotal(vector<vector<int>>& triangle) {
        int m = triangle.size();
        int n = triangle[m - 1].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        int ans = findmin(0, 0, triangle, dp);
        return ans;
    }
};

// ===>>> Tabulation <<============

#include <bits/stdc++.h>
using namespace std;

// Function to find the minimum path sum in the given triangle using dynamic programming
int minimumPathSum(vector<vector<int> > &triangle, int n) {
    // Create a 2D DP (dynamic programming) array to store minimum path sums
    vector<vector<int> > dp(n, vector<int>(n, 0));

    // Initialize the bottom row of dp with the values from the triangle
    for (int j = 0; j < n; j++) {
        dp[n - 1][j] = triangle[n - 1][j];
    }

    // Iterate through the triangle rows in reverse order
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i; j >= 0; j--) {
            // Calculate the minimum path sum for the current cell
            int down = triangle[i][j] + dp[i + 1][j];
            int diagonal = triangle[i][j] + dp[i + 1][j + 1];

            // Store the minimum of the two possible paths in dp
            dp[i][j] = min(down, diagonal);
        }
    }

    // The top-left cell of dp now contains the minimum path sum
    return dp[0][0];
}



// ===================================>>>>Q12) Minimum/Maximum Falling Path Sum (DP-12) <<<======================================
class Solution {
public:
    int findminFallingPathSum(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp) {
        // Base case: out of boundary
        if (j >= matrix[0].size() || j < 0) {
            return 1e9; // large number to signify an invalid path
        }
        // Base case: top row
        if (i == 0) {
            return matrix[0][j];
        }

        // Check if the result is already computed
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        // Recursive calculation of minimum path sum
        int up = matrix[i][j] + findminFallingPathSum(i - 1, j, matrix, dp);
        int ldig = matrix[i][j] + findminFallingPathSum(i - 1, j - 1, matrix, dp);
        int rdig = matrix[i][j] + findminFallingPathSum(i - 1, j + 1, matrix, dp);

        dp[i][j] = min(up, min(ldig, rdig));
        return dp[i][j];
    }

    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if (n == 0 || matrix[0].size() == 0) {
            return 0; // edge case: empty matrix
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));

        int mini = INT_MAX;
        for (int i = 0; i < n; i++) {
            int value = findminFallingPathSum(n - 1, i, matrix, dp);
            mini = min(mini, value);
        }
        return mini;
    }
};

// ====================>>>> Q13)3-d DP : Ninja and his friends (DP-13) <<===============================
#include <bits/stdc++.h>
using namespace std;

int findmaximum(int i, int j1, int j2, vector<vector<int>> &grid) {
    int row = grid.size();
    int col = grid[0].size();

    // boundary check
    if(j1 < 0 || j1 >= col || j2 < 0 || j2 >= col){
        return -1e8;  // using a large negative value instead of INT_MIN
    }

    // base case
    if(i == row - 1){
        // same cell taken value once 
        if(j1 == j2){
            return grid[i][j1];
        } else {
            return grid[i][j1] + grid[i][j2];
        }
    }

    // all possible moves
    int dir[] = {-1, 0, 1};
    int maxi = INT_MIN;
    for(int di = 0; di < 3; di++) {
        for(int dj = 0; dj < 3; dj++) {
            int newJ1 = j1 + dir[di];
            int newJ2 = j2 + dir[dj];
            int path;
            if(j1 == j2){
                path = grid[i][j1] + findmaximum(i + 1, newJ1, newJ2, grid);
            } else {
                path = grid[i][j1] + grid[i][j2] + findmaximum(i + 1, newJ1, newJ2, grid);
            }
            maxi = max(maxi, path);
        }
    }
    return maxi;
}

int maximumChocolates(int r, int c, vector<vector<int>> &grid) {
    return findmaximum(0, 0, c - 1, grid);
}

======>>> memoization <<<================
#include <bits/stdc++.h>
using namespace std;

int findmaximum(int i, int j1, int j2, vector<vector<int>> &grid , vector<vector<vector<int>>> &dp) {
    int row = grid.size();
    int col = grid[0].size();

    // boundary check
    if(j1 < 0 || j1 >= col || j2 < 0 || j2 >= col){
        return -1e8;  // using a large negative value instead of INT_MIN
    }

    // base case
    if(i == row - 1){
        // same cell taken value once 
        if(j1 == j2){
            return grid[i][j1];
        } else {
            return grid[i][j1] + grid[i][j2];
        }
    }
    if(dp[i][j1][j2] != -1){
        return dp[i][j1][j2];
    }

    // all possible moves
    int dir[] = {-1, 0, 1};
    int maxi = INT_MIN;
    for(int di = 0; di < 3; di++) {
        for(int dj = 0; dj < 3; dj++) {
            int newJ1 = j1 + dir[di];
            int newJ2 = j2 + dir[dj];
            int path;
            if(j1 == j2){
                path = grid[i][j1] + findmaximum(i + 1, newJ1, newJ2, grid , dp);
            } else {
                path = grid[i][j1] + grid[i][j2] + findmaximum(i + 1, newJ1, newJ2, grid , dp);
            }
            maxi = max(maxi, path);
        }
    }
    dp[i][j1][j2] = maxi;

    return dp[i][j1][j2];
}

int maximumChocolates(int r, int c, vector<vector<int>> &grid) {
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, -1)));
    return findmaximum(0, 0, c - 1, grid , dp);
} 

========>>>> Tabulation (due  rahega kabhi or karege ) <=====








//============================================>>>>*************************<<<<<==============================================
//============================================>>>>>> DP ON SUBSEQUENCES <<<<<<================================================
//============================================>>>>*************************<<<<<==============================================

Q14) ========================>>>>> Subset sum Problem  <<<======================
// =======>>> brute force approach <<<<====
class Solution{   
public:
    bool findisSubsetsum(int index , int sum , vector<int>&arr){
        if(index == 0 && sum != 0){
            return false;
        }
        if(sum == 0){
            return true;
        }
        
        // pick 
        bool pick = false;
        if(arr[index -1] <= sum){
            pick = findisSubsetsum(index -1 , sum - arr[index -1] , arr);
        }
        
        // dont pick 
        bool notpick = findisSubsetsum(index -1 , sum  , arr);
        
        
        return pick || notpick ;
    }
    bool isSubsetSum(vector<int>arr, int sum){
        int n = arr.size();
        bool ans = findisSubsetsum(n-1 , sum , arr);
        return ans;
    }
};

//==========>>> memoization <<<=======
class Solution{   
public:
    bool findisSubsetsum(int index , int sum , vector<int>&arr , vector<vector<int>>&dp){
       
        if(sum == 0){
            return true;
        }
        if(index == 0){
            return arr[0] == sum;
        }
        
        if(dp[index][sum] != -1){
            return dp[index][sum];
        }
        
        
        // dont pick 
        bool notpick = findisSubsetsum(index -1 , sum  , arr , dp);
        
        
        // pick 
        bool pick = false;
        if(arr[index] <= sum){
            pick = findisSubsetsum(index -1 , sum - arr[index] , arr , dp);
        }
        
        dp[index][sum] = pick || notpick;
        
        return dp[index][sum];
    }
    bool isSubsetSum(vector<int>arr, int sum){
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(sum + 1, -1)); 
        bool ans = findisSubsetsum(n-1 , sum , arr , dp);
        return ans;
    }
};

// ========>>> Tabulation jarurii nahi hai <<<=====>> easy hi hai <<<=============



// ===========================>>> Q15) Partition Equal Subset Sum (DP- 15)  <<<====
privously have done this question in aditya dp lec
======>>> stivar bhaiya <<<====
class Solution {
public:
    bool canpartition(int index , int sum , vector<int>&nums , vector<vector<int>> &dp){
        if(sum == 0) return true;

        if(index == 0){
            return nums[0] == sum;
        }

        if(dp[index][sum] != -1){
            return dp[index][sum];
        }

        // donot pick 
        bool notpick =  canpartition(index -1 , sum  , nums , dp);

        // pick 
        bool pick = false;
        if(nums[index] <= sum){
            pick =  canpartition(index -1 , sum - nums[index] , nums , dp);
        }

        dp[index][sum] = pick || notpick;
        return dp[index][sum];
    }
    bool canPartition(vector<int>& nums) {
        
        // memoization code 
        int n = nums.size();
        if(n == 1) return false; 
        int sum = 0;
        for(int i = 0; i < nums.size()  ; i++){
            sum = sum + nums[i];
        }

        if(sum % 2 != 0){
            return false;
        }
        int W = sum/2;
        vector<vector<int>>dp(n , vector<int>(W+1 , -1));
        bool ans = canpartition(n-1 , W, nums , dp);
        return ans;
    }
};

// =============================>>> Q16) Count Subsets with Sum K (DP - 17)   <<<==========================================


=====>>> EK BAAR ISS QUESTION KO DEKHNA HAI <<<<==============
// ==>>> brute force code <<<<============ 
....... give TLE ........
complexity :- 2^n
0 ≤ arr[i] ≤ 10^6 ===>>> N = 10^6 VERY LARGE DEFENETILY GIVE TLE ====>>> THINK OF DP
#include <vector>

class Solution {
  const int MOD = 1e9 + 7;

public:
    void countsumsubseq(int index, int arr[], int n, int sum, int value, int &count) {
        if (value == sum) {
            count = (count + 1) % MOD;
            return;
        }

        if (index >= n || value > sum) {
            return;
        }

        // Include the current element
        countsumsubseq(index + 1, arr, n, sum, value + arr[index], count);

        // Exclude the current element
        countsumsubseq(index + 1, arr, n, sum, value, count);
    }

    int perfectSum(int arr[], int n, int sum) {
        int count = 0;
        countsumsubseq(0, arr, n, sum, 0, count);
        return count;
    }
};
=======================>>> memoization method <<<+
=====>>> correct code hai <<========================
// =============>>>> this code handle the zeros case also so this is beeter than privous <<<============
==============>>> case when    0 <=arr[i] <=10000   <<<==================
 class Solution {
public:
    const int MOD = 1000000007;

    int findcount(int index, int sum, int arr[], vector<vector<int>>& dp) {
        if (index == 0) {
            if (sum == 0 && arr[0] == 0) {
                return 2; // two ways: including or not including the zero element
            }
            if (sum == 0 || sum == arr[0]) {
                return 1; // one way to achieve the sum
            }
            return 0; // no way to achieve the sum
        }

        if (dp[index][sum] != -1) {
            return dp[index][sum];
        }

        // don't pick the current element
        int notpick = findcount(index - 1, sum, arr, dp);

        // pick the current element
        int pick = 0;
        if (arr[index] <= sum) {
            pick = findcount(index - 1, sum - arr[index], arr, dp);
        }

        dp[index][sum] = (notpick + pick) % MOD;
        return dp[index][sum];
    }

    int perfectSum(int arr[], int n, int sum) {
        vector<vector<int>> dp(n, vector<int>(sum + 1, -1));
        return findcount(n - 1, sum, arr, dp);
    }
};

 
// ==============>>> case when    1<=arr[i] <=10000   <<<==================
public:
    const int MOD = 1000000007;

    int findcount(int index, int sum, int arr[], vector<vector<int>>& dp) {
        if (sum == 0) {
            return 1;
        }
        
        if (index == 0) {
            return arr[0] == sum 
        }

        if (dp[index][sum] != -1) {
            return dp[index][sum];
        }
        
        // don't pick the current element
        int notpick = findcount(index - 1, sum, arr, dp) % MOD;
        
        // pick the current element
        int pick = 0;
        if (arr[index] <= sum) {
            pick = findcount(index - 1, sum - arr[index], arr, dp) % MOD;
        }
        
        dp[index][sum] = (notpick + pick) % MOD;
        return dp[index][sum];
    }

    int perfectSum(int arr[], int n, int sum) {
        vector<vector<int>> dp(n, vector<int>(sum + 1, -1));
        return findcount(n - 1, sum, arr, dp);
    }
};
#include <vector>
using namespace std;
#include <vector>
using namespace std;

class Solution {
public:
    const int MOD = 1e9 + 7;

    int countperfectsum(int arr[], int sum, int n, vector<vector<int>>& dp) {
      // Initialisation of the code     
        
      // making 1 row zero of dp array 
       for(int j = 0  ; j <= sum ; j++){
           dp[0][j] = 0;
       }
       
       // making 1st column to 1
       for(int i = 0 ; i <= n ; i++){
           dp[i][0] = 1;
       }
       
       // main code 
       for(int i = 1 ; i <= n  ; i ++){
           for(int j = 0  ; j <= sum ; j++){
               if(arr[i-1] <= j){
                   dp[i][j] = (dp[i-1][j-arr[i-1]] + dp[i-1][j]) % MOD;
               }
               else if(arr[i-1] > j){
                   dp[i][j] = dp[i-1][j];
               }
           }
       }
       return dp[n][sum];
       
    }

    int perfectSum(int arr[], int n, int sum) {
        // Initialize the dp table with -1
        vector<vector<int>> dp(n + 1, vector<int>(sum + 1));
        return countperfectsum(arr, sum, n, dp);
    }
};

/// ==========================>>>> Q17)Partition Set Into 2 Subsets With Min Absolute Sum Diff (DP- 16)<<<<======================
class Solution{

  public:
	int minDifference(int arr[], int n)  { 
        int Totalsum = 0;
        for (int i = 0; i < n; i++) {
            Totalsum += arr[i];
        }
       
        vector<vector<bool>> dp(n, vector<bool>(Totalsum + 1, false));
        
        // Base case: Any subset can sum to 0 by not including any elements.
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }

        // Base case: The subset sum that includes only the first element.
        if (arr[0] <= Totalsum) {
            dp[0][arr[0]] = true;
        }

        // Fill the dp table
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= Totalsum; j++) {
                // Not take
                bool nottake = dp[i-1][j];

                // Take
                bool take = false;
                if (arr[i] <= j) {
                    take = dp[i-1][j-arr[i]];
                }

                dp[i][j] = take || nottake;
            }
        }
        
        // Find the minimum difference
        int mini = INT_MAX;
        for (int target = 0; target <= Totalsum / 2; target++) {
            if (dp[n-1][target] == true) {
                int sumdiff = abs(target - (Totalsum - target));
                mini = min(mini, sumdiff);
            }
        }

        return mini;
 // Your code goes here
	} 
};

//=====>>> Memoization at the time of rivision <<<<<================





// ===============>>>>> Q5) 0/1 Knapsack (DP - 19) <<<<===================
class Solution
{
public:
    // Function to return max value that can be put in knapsack of capacity W.
    int findknapSack(int ind, int Weight, int wt[], int val[], vector<vector<int>> &dp) {
        if (Weight == 0 || ind < 0) {
            return 0;
        }

        if (dp[ind][Weight] != -1) {
            return dp[ind][Weight];
        }

        // notpick
        int notpick = findknapSack(ind - 1, Weight, wt, val, dp);

        int pick = INT_MIN;
        if (wt[ind] <= Weight) {
            pick = val[ind] + findknapSack(ind - 1, Weight - wt[ind], wt, val, dp);
        }

        return dp[ind][Weight] = max(notpick, pick);
    }

    int knapSack(int W, int wt[], int val[], int n) {
        vector<vector<int>> dp(n, vector<int>(W + 1, -1));
        int ans = findknapSack(n - 1, W, wt, val, dp);
        return ans;
    }
};
// =========>>>> Better approach to know about the base case how to write code <<==========
#include <bits/stdc++.h> 

int findknapsack(int ind , int maxWeight , vector<int> &weight , vector<int> &value , vector<vector<int>> &dp){

        // base case ===>> socho 
		if(ind == 0){
			// case 1 ==>>> last element ka weight bag ka barabar ho ya usse chota ho 
            if(weight[ind] <= maxWeight){
				return value[ind];
			}
			// case 2 ==>>> last element ka weight bada ho 
			else{
				return 0;
			}
		}


        if(dp[ind][maxWeight] != -1){
			return dp[ind][maxWeight];
		}
		// all possibility 
        int notpick = 0 + findknapsack(ind -1 , maxWeight , weight , value , dp);

        // pick me two case hai ek baar weight jada ho gaya 
		int pick = INT_MIN;   // when weight of the bag is small
		if(weight[ind] <= maxWeight){
			pick = value[ind] + findknapsack(ind -1 , maxWeight-weight[ind] , weight , value , dp);
		}

        // maximum
		dp[ind][maxWeight] = max(pick , notpick);
		return dp[ind][maxWeight];

}
int knapsack(vector<int> weight, vector<int> value, int n, int maxWeight) 
{
	// must visit the copy learn more about this question
	vector<vector<int>>dp(n , vector<int>(maxWeight + 1 , -1));
	int ans = findknapsack(n-1 , maxWeight , weight , value , dp);
	return ans;
}

//===================================>> Q6)Minimum Coins (DP - 20) <<============

class Solution {
public:
    int findmincoin(int ind , int amount , vector<int> & coins , vector<vector<int>> &dp){
        if (amount == 0) {
            return 0;
        }
        if (ind == 0) {
            if (amount % coins[ind] == 0) {
                return amount / coins[ind];
            } else {
                return INT_MAX;
            }
        }


        if(dp[ind][amount] != -1){
            return dp[ind][amount];
        }

        // since repetation of coin hai ====>>> possibility to 2 hi hai pick or not pick 
        // notpick 
        int notpick = 0 + findmincoin(ind-1 , amount , coins , dp);
        
        // pick 
        int pick = INT_MAX;
        if(coins[ind] <= amount){
            int res  = findmincoin(ind , amount-coins[ind] , coins , dp);   // since repetatin is allowed
            if(res != INT_MAX){
                pick = res + 1;
            }
        }
       
        dp[ind][amount] = min(notpick , pick);
        return dp[ind][amount];
    }
    int coinChange(vector<int>& coins, int amount) {
        // minimum no of coin chahiye to make this amount ===>>> repetation bhi hai 
        int n = coins.size();
        vector<vector<int>>dp(n , vector<int>(amount + 1 , -1));
        int ans = findmincoin(n-1 , amount , coins , dp);
        if(ans == INT_MAX){
            return -1;
        }
        return ans;
    }
};

// ==================>>>> better way as i expected <<<============
class Solution {
public:
    int findmincoin(int ind , int amount , vector<int> & coins , vector<vector<int>> &dp){
       
        if (ind == 0) {
            if (amount % coins[ind] == 0) {
                return amount / coins[ind];
            } else {
                return INT_MAX;
            }
        }


        if(dp[ind][amount] != -1){
            return dp[ind][amount];
        }

        // since repetation of coin hai ====>>> possibility to 2 hi hai pick or not pick 
        // notpick 
        int notpick = 0 + findmincoin(ind-1 , amount , coins , dp);
        
        // pick 
        int pick = INT_MAX;
        if(coins[ind] <= amount){
            int res  = findmincoin(ind , amount-coins[ind] , coins , dp);   // since repetatin is allowed
            if(res != INT_MAX){
                pick = res + 1;
            }
        }
       
        dp[ind][amount] = min(notpick , pick);
        return dp[ind][amount];
    }
    int coinChange(vector<int>& coins, int amount) {
        // minimum no of coin chahiye to make this amount ===>>> repetation bhi hai 
        int n = coins.size();
        vector<vector<int>>dp(n , vector<int>(amount + 1 , -1));
        int ans = findmincoin(n-1 , amount , coins , dp);
        if(ans == INT_MAX){
            return -1;
        }
        return ans;
    }
};

// ============================>>> Q7) Coin Change 2 (DP - 22) <<================================================
class Solution {
public:
    int findchange(int ind , int amount , vector<int> & coins , vector<vector<int>> &dp){
        // base case
        if(amount == 0){
            return 1;
        }
        if(ind == 0){
           if(amount % coins[ind] == 0){
            return 1;
           }else{
            return 0;
           }
        }

        if(dp[ind][amount] != -1){
            return dp[ind][amount];
        }
        
        // possibility 
        int notpick = findchange(ind - 1 , amount , coins , dp );

         int pick = 0;
         if(coins[ind] <= amount){
            pick = findchange(ind , amount-coins[ind] , coins , dp );
         }
        // count hai return left + right 
        dp[ind][amount] = pick + notpick;
        return dp[ind][amount];
    }
    int change(int amount, vector<int>& coins) {
         int n = coins.size();
         vector<vector<int>>dp(n , vector<int>(amount +1 , -1));
         int count = findchange(n-1 , amount , coins , dp);
         return count;
    }
};

// ========================>>>> Q8) Rod Cutting Problem | (DP - 24) <<<<<===============
// ==============>>> almost same as the as the unbounded knapsack but only change is here we have create a weight vector according to question to make it similar to knapsack <<<<<<===========================
class Solution{
  public:
    int findmaxprice(int ind , int W , int price[] , vector<int> & wt , vector<vector<int>> &dp){
        if(ind == 0){
           return (W / wt[0]) * price[0];
        }
        
        if(dp[ind][W] != -1){
            return dp[ind][W];
        }
        
        // all stuff
        int notpick = findmaxprice(ind -1 , W , price , wt , dp);
        
        int pick = INT_MIN;
        if(wt[ind] <= W){
            pick =  price[ind] + findmaxprice(ind, W- wt[ind], price , wt , dp);
        }
        
        dp[ind][W] = max(notpick , pick);
        return dp[ind][W];
    }
    int cutRod(int price[], int n) {
        //code here ===>>> similar code hai 
        // lwt see 1 based indexing kya fark padta hai 
        
       // according to my approach creae a wt array by given data 
       vector<int> wt(n);
        for (int i = 0; i < n; i++) {
            wt[i] = i + 1;
        }
       
       // ======>>> weight array create kar diya simple hai jaise pahle wala question tha <<==
       vector<vector<int>>dp(n , vector<int>(n+1 , -1));
       int ans = findmaxprice(n-1 , n , price , wt, dp);
       return ans;
        
    }
};

// =====>>>> More better way with <<<<==========
//{ Driver Code Starts
// Initial Template for C++

#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
// User function Template for C++

class Solution{
  public:
    int findmaxprice(int ind , int W , int price[] , vector<vector<int>> &dp){
        if(ind == 0){
           return W  * price[0];
        }
        
        if(dp[ind][W] != -1){
            return dp[ind][W];
        }
        
        // all stuff
        int notpick = findmaxprice(ind -1 , W , price , dp);
        
        int pick = INT_MIN;
        int index = ind + 1;
        if(index <= W){
            pick =  price[ind] + findmaxprice(ind, W- index, price , dp);
        }
        
        dp[ind][W] = max(notpick , pick);
        return dp[ind][W];
    }
    int cutRod(int price[], int n) {
        
       vector<vector<int>>dp(n , vector<int>(n+1 , -1));
       int ans = findmaxprice(n-1 , n , price , dp);
       return ans;
        
    }
};

//{ Driver Code Starts.

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int a[n];
        for (int i = 0; i < n; i++) 
            cin >> a[i];
            
        Solution ob;

        cout << ob.cutRod(a, n) << endl;
    }
    return 0;
}
// } Driver Code Ends

// ==========================>>>> Count Partitions with Given Difference (DP - 18)  <<<<<===================================
class Solution {
public:
    int MOD = 10000007;
    int findcountpartitions(int ind, int tolsum, vector<int>& arr, vector<vector<int>>& dp) {
        if (ind == 0) {
            if (tolsum == 0 && arr[ind] == 0) {
                return dp[ind][tolsum] = 2;
            }
            if (tolsum == 0 || arr[ind] == tolsum) {
                return dp[ind][tolsum] = 1;
            }
            return dp[ind][tolsum] = 0;
        }
        if (dp[ind][tolsum] != -1) {
            return dp[ind][tolsum];
        }

        // Not pick
        int notpick = findcountpartitions(ind - 1, tolsum, arr, dp);
        
        // Pick
        int pick = 0;
        if (arr[ind] <= tolsum) {
            pick = findcountpartitions(ind - 1, tolsum - arr[ind], arr, dp);
        }
        
        dp[ind][tolsum] = (pick + notpick) % MOD;
        return dp[ind][tolsum];
    }

    int countPartitions(int n, int d, vector<int>& arr) {
        int tolsum = 0;
        for (int i = 0; i < n; i++) {
            tolsum += arr[i];
        }
      
        // Base case check
        if ((tolsum - d) % 2 != 0 || tolsum < d) {
            return 0;
        }

        int sum = (tolsum - d) / 2;
    
        vector<vector<int>> dp(n, vector<int>(sum + 1, -1));
      
        int count = findcountpartitions(n - 1, sum, arr, dp);
        return count % MOD;
    }
};

// =======================>>>>> Target Sum (DP - 21)  <<<<===============================
 // similar question as partition into two subset with  diff equal to d;===>>> exactly same hai  
// ekdam same question hai sochna ek baar baith ke acche se kaise usko isme break kar ke solve kar sakte hai assan tha banna bhi diye kuch matlab achhha hai yaad rah raha ahia 
class Solution {
public:
    int findcount(int ind , int target , vector<int> & nums , vector<vector<int>> & dp){
        // base case 
        if(ind == 0){
            if(nums[ind] == 0 && target == 0 ){
                return 2;
            }
            if(target == 0 || target == nums[0]){
                return 1;
            }
            else{
                return 0;
            }
        }

        if(dp[ind][target] != -1){
            return dp[ind][target];
        }
        // stuffs 
        int notpick = findcount(ind -1 , target , nums , dp);

        int pick = 0;
        if(nums[ind] <= target){
            pick = findcount(ind -1 , target- nums[ind] , nums , dp);
        }
        // count ways hai  ===>> + 
        dp[ind][target] = pick + notpick;
        return dp[ind][target]; 


    }
    int findTargetSumWays(vector<int>& nums, int target) {
      // similar question as partition into two subset with  diff equal to d;===>>> exactly same hai 
      int n = nums.size();
      int Tolsum = 0;
      for(int i = 0  ; i < n ; i++){
        Tolsum = Tolsum + nums[i];
      }

      // as we know s1 + s2 = Tolsum ==>>
      // s1 - s2 = d ==>>> Tolsum - 2s1 = d ==>> s1 = (Tolsum - d)/2
      if((Tolsum - target) % 2 != 0 || Tolsum - target < 0){
        return 0;
      }
      
      int sum = (Tolsum - target)/2;
      vector<vector<int>>dp(n , vector<int>(sum + 1 , -1));
      int ans = findcount(n-1 , sum , nums , dp );
      return ans;

    }
};



// ================================================================================================================================
// ===========================================>>>>> DP ON STRINGS <<<<=============================================================
// ================================================================================================================================

=============================>>> Q1)Longest Common Subsequence | (DP - 25) <<<====================================================
class Solution {
public:
    int findlongestCommon(int ind1 , int ind2 , string & s1 , string & s2 , vector<vector<int>> &dp){
        // base case 
        if(ind1 < 0 || ind2 < 0){
            return 0;
        }
        
        if(dp[ind1][ind2] != -1){
            return dp[ind1][ind2];
        }
        // possibility of stuff 
        // match 
        if(s1[ind1] == s2[ind2] ){
            return dp[ind1][ind2] = 1 + findlongestCommon(ind1 -1 , ind2 -1 , s1 , s2 , dp);
        }

        // not match 
        return dp[ind1][ind2] = 0 + max(findlongestCommon(ind1 -1 , ind2 , s1 , s2 , dp) , findlongestCommon(ind1 , ind2-1 , s1 , s2 , dp));

    }
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();

        vector<vector<int>>dp(n , vector<int>(m , -1));
        int ans = findlongestCommon(n-1 ,  m-1 , text1 , text2 , dp);
        return ans;
    }
};
// ===================>>> After shifting the index you have to know because in some case it is easier to think in shifting so we can do that 

// =================>>>> tabulation <<<<=======================
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int findlongestCommon(int n, int m, string &s1, string &s2, vector<vector<int>> &dp) {
        // Initialize the base cases
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }

        for (int j = 0; j <= m; j++) {
            dp[0][j] = 0;
        }

        // Fill the DP table using bottom-up approach
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n][m];
    }

    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        return findlongestCommon(n, m, text1, text2, dp);
    }
};

// ==============>>>
class Solution {
public:
    int findlongestCommon(int ind1 , int ind2 , string & s1 , string & s2 , vector<vector<int>> &dp){
        // base case 
        if(ind1 == 0 || ind2 == 0){
            return 0;
        }
        
        if(dp[ind1][ind2] != -1){
            return dp[ind1][ind2];
        }
        // possibility of stuff 
        // match 
        if(s1[ind1-1] == s2[ind2-1] ){
            return dp[ind1][ind2] = 1 + findlongestCommon(ind1 -1 , ind2 -1 , s1 , s2 , dp);
        }

        // not match 
        return dp[ind1][ind2] = 0 + max(findlongestCommon(ind1 -1 , ind2 , s1 , s2 , dp) , findlongestCommon(ind1 , ind2-1 , s1 , s2 , dp));

    }
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();

        vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));
        int ans = findlongestCommon(n ,  m , text1 , text2 , dp);
        return ans;
    }
};

// =============================================>>> Q2) Print Longest Common Subsequence | (DP - 26)  <<<<============================================
// =======================>>> it return only one LCS <<<=====================
{
	public:
		int findlen(int ind1 , int ind2 , string  &s1  , string &s2 , vector<vector<int>> & dp){
	         int  n = s1.size();
	         int m  = s2.size();
	         for (int i = 0; i <= n; i++) {
                 dp[i][0] = 0;
             }
             for (int i = 0; i <= m; i++) {
               dp[0][i] = 0;
             }
             
              for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                   if (s1[i - 1] == s2[j - 1])
                      dp[i][j] = 1 + dp[i - 1][j - 1];
                        else
                   dp[i][j] = 0 + max(dp[i- 1][j], dp[i][j - 1]);
                   }
               }
               
               return dp[ind1][ind2];
	    }
		vector<string> all_longest_common_subsequences(string s, string t)
		{
		   // We have to apply tabulation method 
		   // we cant use the memoization method 
		   vector<string>ans;
		   int n = s.size();
		   int m = t.size();
		   
		   vector<vector<int>>dp(n+1 , vector<int>(m+1 , 0));
		   int len = findlen(n, m , s, t , dp);
		   
		   // correct as expected tha 
		  // for(int i = 0 ; i <= n ; i++){
		  //     for(int j = 0; j <= m ; j++){
		  //         cout<<dp[i][j]<<" ";
		  //     }
		  //     cout<<endl;
		  // }
		   string temp = "";
		   for(int i = 0 ; i < len ; i++){
		       temp += '$';
		   }
		   int index = len-1;
		   
		   int i = n ;
		   int j  = m ;
		   while(i > 0 && j > 0){
		       if(s[i-1] == t[j-1]){
		           temp[index] = s[i-1];
		           index--;
		           i--;
		           j--;
		       }
		       else if(dp[i-1][j] > dp[i][j-1]){
		           i--;
		       }else{
		           j--;
		       }
		   }
		   
		   ans.push_back(temp);
		   return ans;
		}
};
// ==============>>>> IMPORTANT HAI MUST <<<<=========
// ========================>>> Q3) Print all LCS sequences  <<<<<================
#include <vector>
#include <string>
#include <algorithm>

class Solution {
public:
    using namespace std;

    int findlen(int ind1, int ind2, string &s1, string &s2, vector<vector<int>> &dp) {
        int n = s1.size();
        int m = s2.size();
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i <= m; i++) {
            dp[0][i] = 0;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[ind1][ind2];
    }
    
    void findAllLCS(int i, int j, string &s1, string &s2, vector<vector<int>> &dp, string currentLCS, vector<string> &ans) {
        if (i == 0 || j == 0) {
            reverse(currentLCS.begin(), currentLCS.end());
            ans.push_back(currentLCS);
            return;
        }
        
        if (s1[i - 1] == s2[j - 1]) {
            findAllLCS(i - 1, j - 1, s1, s2, dp, currentLCS + s1[i - 1], ans);
        } else {
            if (dp[i - 1][j] == dp[i][j]) {
                findAllLCS(i - 1, j, s1, s2, dp, currentLCS, ans);
            }
            if (dp[i][j - 1] == dp[i][j]) {
                findAllLCS(i, j - 1, s1, s2, dp, currentLCS, ans);
            }
        }
    }
    
    vector<string> all_longest_common_subsequences(string s, string t) {
        vector<string> ans;
        int n = s.size();
        int m = t.size();
        
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int len = findlen(n, m, s, t, dp);
        
        findAllLCS(n, m, s, t, dp, "", ans);
        
        // Remove duplicates
        sort(ans.begin(), ans.end());
        ans.erase(unique(ans.begin(), ans.end()), ans.end());
        
        return ans;
    }
};

// ================>>>>> further optimised code <<<<================
class Solution{
    
	public:
	
	vector<string> all_longest_common_subsequences(string s, string t){
	    
	    int n = s.size();
	    int m = t.size();
	    vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
	    
	    // Base cases
	    for(int j=0; j<=m; j++) dp[0][j] = 0;
	    for(int i=0; i<=n; i++) dp[i][0] = 0;
	    
	    // States
	    for(int i=1; i<=n; i++){
	        for(int j=1; j<=m; j++){
	            
	            // Recursion
	            if(s[i - 1] == t[j - 1]){
	                dp[i][j] = 1 + dp[i - 1][j - 1];
	            }
	            else{
	                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	            }
	            
	        }
	    }
	    
	    set<string> ans;
	    queue<pair<pair<int, int>, string>> q;
	    q.push({{n, m}, ""});
	    
	    // BFS in dp array
	    while(!q.empty()){
	        
	        int x = q.front().first.first;
	        int y = q.front().first.second;
	        string str = q.front().second;
	        q.pop();
	        
	        if(x == 0 || y == 0) ans.insert(str);
	        else{
	            
	            if(s[x - 1] == t[y - 1]){
	                q.push({{x - 1, y - 1}, s[x - 1] + str});
	            }
	            else{
	                
	                if(dp[x - 1][y] >= dp[x][y - 1]){
	                     q.push({{x - 1, y}, str});
	                 }
	                
	                 if(dp[x][y - 1] >= dp[x - 1][y]){
	                     q.push({{x, y - 1}, str});
	                 }
	            
	            }
	            
	        }
	        
	    }
	    
	    return vector<string>(ans.begin(), ans.end());
	    
	}

    
};

//=============================>>>> Q3) Longest Common Substring | (DP - 27)   <<<=============================================
class Solution{
    public:
    
    int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        vector<vector<int>>dp(n+1 , vector<int>(m+1 , 0));
        
        // initialiastion
        for(int i = 0 ; i <= n ; i++){
            dp[i][0] = 0;
        }
        for(int j = 0 ; j <= m ; j++){
            dp[0][j] = 0;
        }
        
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(S1[i-1] == S2[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    dp[i][j] = 0;
                }
            }
        }
        
        int ans = INT_MIN;
        for( int i = 0; i <= n ; i++){
            for(int j = 0 ; j <= m ; j++){
                if(dp[i][j] > ans){
                    ans = dp[i][j];
                }
            }
        }
        
        return ans;
    }
};

=============>>> More better approach <<<<============
class Solution{
    public:
    
    int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        vector<vector<int>>dp(n+1 , vector<int>(m+1 , 0));
        
        int ans = 0;
        for(int i = 1 ; i <= n ; i++){
            for(int j = 1 ; j <= m ; j++){
                if(S1[i-1] == S2[j-1]){
                    dp[i][j] = 1 + dp[i-1][j-1];
                    if(dp[i][j] > ans ){
                        ans = dp[i][j];
                    }
                }else{
                    dp[i][j] = 0;
                }
            }
        }
        
       
        
        return ans;
    }
};

// ==============================>>> Q4)]Longest Palindromic Subsequence | (DP-28) <<<===========================================
class Solution {
public:
    int findlongestpalindromsub(int ind1 , int ind2 , string &s1  , string &s2 , vector<vector<int>> &dp){
        if(ind1 == 0 || ind2 == 0){
            return 0;
        }

        if(dp[ind1][ind2] != -1){
            return dp[ind1][ind2];
        }

        // if match 
        if(s1[ind1 -1 ]  == s2[ind2-1]){
            return dp[ind1][ind2] =  1 + findlongestpalindromsub(ind1 - 1 , ind2-1 , s1 , s2 , dp);
        }


        // not match 
        return dp[ind1][ind2] = max(findlongestpalindromsub(ind1 -1 , ind2 , s1 , s2 , dp) , findlongestpalindromsub(ind1 , ind2-1 , s1 , s2 , dp));
    }
    int longestPalindromeSubseq(string s) {
        cout<<s<<endl;
        string s2 =  s;
        reverse(s2.begin() , s2.end());
        int n = s.size();
        int m = s2.size();
        vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));
        int len = findlongestpalindromsub(n , m , s , s2 , dp);
        return len ;
    }
};
// ====================>>> Tabulation method <<=======
 int findlongestCommon(int n, int m, string &s1, string &s2, vector<vector<int>> &dp) {
        // Initialize the base cases
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }

        for (int j = 0; j <= m; j++) {
            dp[0][j] = 0;
        }

        // Fill the DP table using bottom-up approach
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n][m];
    }
 int longestPalindromeSubseq(string s) {
        cout<<s<<endl;
        string s2 =  s;
        reverse(s2.begin() , s2.end());
        int n = s.size();
        int m = s2.size();
        vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));
        int len = findlongestCommon(n , m , s , s2 , dp);
        return len ;
    }


// ===========================================>>>> 
