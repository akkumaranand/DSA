==============>>> Q1) Fibbonacci series <<=================
// ======>> brute force approach <<===
class Solution {
public:
    
    int fib(int n) {
       if(n <= 0 || n == 1){
        return n;
       } 

       return fib(n-1) + fib(n-2);
    }
};

// =====>>> optimisation <<===== 
//======>>>> mmemoization <<====
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
        if(n<=0 || n == 1){
            return n;
        } 

        if(dp[n] != -1){
            return dp[n];
        }
        
        dp[n] = findfibb(n-1 , dp) + findfibb(n-2 , dp);

        return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 , -1);
       int ans = findfibb(n , dp);
       return ans;
    }
};
===>> time complexity ==>> O(n)
===>> space complexity ==>> O(N)

// =======>>>>> Tabulation (bottom up) <<<==========
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
       // ====>> bottom up approach <<===
       // initialization hota hai 
       if(n == 0 || n == 1){
        return n;
       }
       dp[0] = 0;
       dp[1] = 1;

       // code 
       
        for(int i = 2 ; i <=n ; i++){
         dp[i] = dp[i-1] + dp[i-2];
       }
       
      

       return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 );
       int ans = findfibb(n , dp);
       return ans;
    }
};
============>>>> important to understand <<<================
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
       // ====>> bottom up approach <<===
       // initialization hota hai 
       // when   n = 0 then why we are assigning dp[1] == >> leading overflow because at that time size is only one of for zero only
       dp[0] = 0;
       if(n > 0){
         dp[1] = 1;
       }
       

       // code 
       
        for(int i = 2 ; i <=n ; i++){
         dp[i] = dp[i-1] + dp[i-2];
       }
       
      

       return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 );
       int ans = findfibb(n , dp);
       return ans;
    }
};
// ==========>>> space optimisation <<<============
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        int prev2 = 0;
        int prev1 = 1;
        int current;

        for (int i = 2; i <= n; ++i) {
            current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }

        return current;
    }
};


// ============================================================>>> Q2) Climbing Stairs  <<=====================================================
// ===========>>> similar Question as fibbonacci series no need to further optimisation  <<<<<============
class Solution {
public:
    int findclimbStairs(int n , vector<int> & dp){
        if(n == 1 || n == 2){
            return n;
        }
        if(dp[n] != -1){
            return dp[n];
        }
       
        dp[n] = findclimbStairs(n-1 , dp) + findclimbStairs(n-2 , dp);
        return dp[n];
    }
    int climbStairs(int n) {
        // memoization solution
        vector<int>dp(n+1 , -1);
        int ans = findclimbStairs(n, dp);
        return ans;
    }
};

//============>> optimised <<<<===
class Solution {
public:
    int findclimbStairs(int n , vector<int> & dp){
        if(n == 0 || n == 1){
            return 1;
        }
        if(dp[n] != -1){
            return dp[n];
        }
        int left = findclimbStairs(n-2 , dp);
        int right = findclimbStairs(n-1 , dp); 
        
        // count all possible ways 
        dp[n] = left + right ;
        return dp[n];
    }
    int climbStairs(int n) {
        // memoization solution
        vector<int>dp(n+1 , -1);
        int ans = findclimbStairs(n, dp);
        return ans;
    }
};

//==================>>> Q3) Frog jump <<<================
=====>>>> brute force approach <<===
#include <bits/stdc++.h> 
int findmin(int index , vector<int> & heights){
    if(index == 0){
        return 0;
    }
    
    // jump from index to index -1 energy lost 
    int left = findmin(index - 1 , heights) + abs(heights[index] - heights[index-1]);
    // to avoid negative
    int right = INT_MAX;
    if(index > 1){
         right = findmin(index - 2 , heights) + abs(heights[index] - heights[index-2]);
    }

    return min(left , right);
}
int frogJump(int n, vector<int> &heights)
{ 
    
   int ans =  findmin(n-1 , heights);
   return ans;
}

//========>>> TOP-DOWN approach <<<============
#include <bits/stdc++.h> 
int findmin(int index , vector<int> & heights , vector<int> &dp){
    if(index == 0){
        return 0;
    }
    
    if(dp[index]  != -1){
        return dp[index];
    }
    
    // jump from index to index -1 energy lost 
    int left = findmin(index - 1 , heights ,dp) + abs(heights[index] - heights[index-1] );
    // to avoid negative
    int right = INT_MAX;
    if(index > 1){
         right = findmin(index - 2 , heights , dp) + abs(heights[index] - heights[index-2]);
    }
    
    dp[index] = min(left , right);
    return dp[index];
}
int frogJump(int n, vector<int> &heights)
{   // using momoization 
    vector<int>dp(n+1 , -1);   // you can take n size but for safe side take n+ 1 
   int ans =  findmin(n-1 , heights , dp);
   return ans;
}
// ===========>>>  bottom Up <<<==========
#include <bits/stdc++.h>
using namespace std;

int frogJump(int n, vector<int> &heights) {
    // Create a dp array to store the minimum energy for each stone
    vector<int> dp(n, 0);

    // Base cases
    dp[0] = 0; // Energy needed to stay on the first stone is 0
     // base condition ko modifies bhi kar sakte hai 
    for (int i = 1; i < n; ++i) {
        // Calculate the cost to jump from the previous stone
        int jumpOneStep = dp[i - 1] + abs(heights[i] - heights[i - 1]);
        
        // Initialize the cost to jump from two stones before with a large value
        int jumpTwoSteps = INT_MAX;

        // Calculate the cost to jump from two stones before if possible
        if (i > 1) {
            jumpTwoSteps = dp[i - 2] + abs(heights[i] - heights[i - 2]);
        }

        // The minimum energy to reach stone i
        dp[i] = min(jumpOneStep, jumpTwoSteps);
    }

    // The minimum energy to reach the last stone
    return dp[n - 1];
}


// =================>>>> space optimisation <<<================
#include <bits/stdc++.h>
using namespace std;

int frogJump(int n, vector<int> &heights) {
    if (n == 1) return 0;

    int prev2 = 0;
    int prev1 = abs(heights[1] - heights[0]);

    for (int i = 2; i < n; ++i) {
        int current = min(prev1 + abs(heights[i] - heights[i - 1]), prev2 + abs(heights[i] - heights[i - 2]));
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}
