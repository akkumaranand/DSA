==============>>> Q1) Fibbonacci series <<=================
// ======>> brute force approach <<===
class Solution {
public:
    
    int fib(int n) {
       if(n <= 0 || n == 1){
        return n;
       } 

       return fib(n-1) + fib(n-2);
    }
};

// =====>>> optimisation <<===== 
//======>>>> mmemoization <<====
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
        if(n<=0 || n == 1){
            return n;
        } 

        if(dp[n] != -1){
            return dp[n];
        }
        
        dp[n] = findfibb(n-1 , dp) + findfibb(n-2 , dp);

        return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 , -1);
       int ans = findfibb(n , dp);
       return ans;
    }
};
===>> time complexity ==>> O(n)
===>> space complexity ==>> O(N)

// =======>>>>> Tabulation (bottom up) <<<==========
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
       // ====>> bottom up approach <<===
       // initialization hota hai 
       if(n == 0 || n == 1){
        return n;
       }
       dp[0] = 0;
       dp[1] = 1;

       // code 
       
        for(int i = 2 ; i <=n ; i++){
         dp[i] = dp[i-1] + dp[i-2];
       }
       
      

       return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 );
       int ans = findfibb(n , dp);
       return ans;
    }
};
============>>>> important to understand <<<================
class Solution {
public:
    int findfibb(int n , vector<int>&dp){
       // ====>> bottom up approach <<===
       // initialization hota hai 
       // when   n = 0 then why we are assigning dp[1] == >> leading overflow because at that time size is only one of for zero only
       dp[0] = 0;
       if(n > 0){
         dp[1] = 1;
       }
       

       // code 
       
        for(int i = 2 ; i <=n ; i++){
         dp[i] = dp[i-1] + dp[i-2];
       }
       
      

       return dp[n];
    } 
    
    int fib(int n) {
       vector<int>dp(n+1 );
       int ans = findfibb(n , dp);
       return ans;
    }
};
// ==========>>> space optimisation <<<============
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        int prev2 = 0;
        int prev1 = 1;
        int current;

        for (int i = 2; i <= n; ++i) {
            current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }

        return current;
    }
};


// ============================================================>>> Q2) Climbing Stairs  <<=====================================================
// ===========>>> similar Question as fibbonacci series no need to further optimisation  <<<<<============
class Solution {
public:
    int findclimbStairs(int n , vector<int> & dp){
        if(n == 1 || n == 2){
            return n;
        }
        if(dp[n] != -1){
            return dp[n];
        }
       
        dp[n] = findclimbStairs(n-1 , dp) + findclimbStairs(n-2 , dp);
        return dp[n];
    }
    int climbStairs(int n) {
        // memoization solution
        vector<int>dp(n+1 , -1);
        int ans = findclimbStairs(n, dp);
        return ans;
    }
};

//============>> optimised <<<<===
class Solution {
public:
    int findclimbStairs(int n , vector<int> & dp){
        if(n == 0 || n == 1){
            return 1;
        }
        if(dp[n] != -1){
            return dp[n];
        }
        int left = findclimbStairs(n-2 , dp);
        int right = findclimbStairs(n-1 , dp); 
        
        // count all possible ways 
        dp[n] = left + right ;
        return dp[n];
    }
    int climbStairs(int n) {
        // memoization solution
        vector<int>dp(n+1 , -1);
        int ans = findclimbStairs(n, dp);
        return ans;
    }
};

//==================>>> Q3) Frog jump <<<================
=====>>>> brute force approach <<===
#include <bits/stdc++.h> 
int findmin(int index , vector<int> & heights){
    if(index == 0){
        return 0;
    }
    
    // jump from index to index -1 energy lost 
    int left = findmin(index - 1 , heights) + abs(heights[index] - heights[index-1]);
    // to avoid negative
    int right = INT_MAX;
    if(index > 1){
         right = findmin(index - 2 , heights) + abs(heights[index] - heights[index-2]);
    }

    return min(left , right);
}
int frogJump(int n, vector<int> &heights)
{ 
    
   int ans =  findmin(n-1 , heights);
   return ans;
}

//========>>> TOP-DOWN approach <<<============
#include <bits/stdc++.h> 
int findmin(int index , vector<int> & heights , vector<int> &dp){
    if(index == 0){
        return 0;
    }
    
    if(dp[index]  != -1){
        return dp[index];
    }
    
    // jump from index to index -1 energy lost 
    int left = findmin(index - 1 , heights ,dp) + abs(heights[index] - heights[index-1] );
    // to avoid negative
    int right = INT_MAX;
    if(index > 1){
         right = findmin(index - 2 , heights , dp) + abs(heights[index] - heights[index-2]);
    }
    
    dp[index] = min(left , right);
    return dp[index];
}
int frogJump(int n, vector<int> &heights)
{   // using momoization 
    vector<int>dp(n+1 , -1);   // you can take n size but for safe side take n+ 1 
   int ans =  findmin(n-1 , heights , dp);
   return ans;
}
// ===========>>>  bottom Up <<<==========
#include <bits/stdc++.h>
using namespace std;

int frogJump(int n, vector<int> &heights) {
    // Create a dp array to store the minimum energy for each stone
    vector<int> dp(n, 0);

    // Base cases
    dp[0] = 0; // Energy needed to stay on the first stone is 0
     // base condition ko modifies bhi kar sakte hai 
    for (int i = 1; i < n; ++i) {
        // Calculate the cost to jump from the previous stone
        int jumpOneStep = dp[i - 1] + abs(heights[i] - heights[i - 1]);
        
        // Initialize the cost to jump from two stones before with a large value
        int jumpTwoSteps = INT_MAX;

        // Calculate the cost to jump from two stones before if possible
        if (i > 1) {
            jumpTwoSteps = dp[i - 2] + abs(heights[i] - heights[i - 2]);
        }

        // The minimum energy to reach stone i
        dp[i] = min(jumpOneStep, jumpTwoSteps);
    }

    // The minimum energy to reach the last stone
    return dp[n - 1];
}


// =================>>>> space optimisation <<<================
#include <bits/stdc++.h>
using namespace std;

int frogJump(int n, vector<int> &heights) {
    if (n == 1) return 0;

    int prev2 = 0;
    int prev1 = abs(heights[1] - heights[0]);

    for (int i = 2; i < n; ++i) {
        int current = min(prev1 + abs(heights[i] - heights[i - 1]), prev2 + abs(heights[i] - heights[i - 2]));
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}


// ======================================>>>> Q4) Frog Jump with k distances(DP-4) <<<======================
// =============>>> link for the code ==>> https://www.geeksforgeeks.org/problems/minimal-cost/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=minimal-cost
// ================>>> Very very important Question  hai <<<======================
// =======>>>> For further optimisation you can visit to previous problem exact similiar to this <<<==================
space complexity :- O(n)
Time complexity :- O(n*k)
//class Solution {
public:
    int findmincost(int index, vector<int> &height, int k, vector<int> &dp) {
        // Base case
        if (index == 0) {
            return 0;
        }
        
        // Memoization check
        if (dp[index] != -1) {
            return dp[index];
        }

        int minii = INT_MAX;
        for (int s = 1; s <= k; ++s) {
            if (index - s >= 0) {
                int jumpCost = findmincost(index - s, height, k, dp) + abs(height[index] - height[index - s]);
                minii = min(minii, jumpCost);
            }
        }
        
        dp[index] = minii;
        return dp[index];
    }

    int minimizeCost(vector<int>& height, int n, int k) {
        vector<int> dp(n, -1);
        return findmincost(n - 1, height, k, dp);
    }
};


// =======================>>>> Q5)Maximum sum of non-adjacent elements (DP 5) <<======================
//========>>> Ek dry run kar ke dekh lena waise yaha tak to asaan hi hai ====>>> jo index ko liye usko add kiye adjacent nahi le sakte to siimply index-2 ko function call kar diye agar pick nahi kiye to simply usko index-1 ko call 
//=====>>> brute force approch <<==========
class Solution {
public:
    int findrob(int index , vector<int>&nums){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          if(index < 0) return 0;

        // ====>>> main code <<<=====
        int pick = nums[index] + findrob(index - 2  , nums);    // qki adjacent nahi hona chahiye isliye -2 liya hu  
        
        // pick nahi kiye
        int donotpick =  0 + findrob(index-1 , nums);

        return max(pick , donotpick);
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int ans = findrob(index , nums);
        return ans;

    } 
            
};

// =============>>> Memoization method <<<<============
class Solution {
public:
    int findrob(int index , vector<int>&nums , vector<int> &dp){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          if(index < 0) return 0;
         
         if(dp[index] != -1){
            return dp[index];
         }
        // ====>>> main code <<<=====
        int pick = nums[index] + findrob(index - 2  , nums , dp);    // qki adjacent nahi hona chahiye isliye -2 liya hu  
        
        // pick nahi kiye
        int donotpick =  0 + findrob(index-1 , nums , dp);

        dp[index] = max(pick , donotpick);

        return dp[index];
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int n = nums.size();
        vector<int>dp(n , -1);
        int ans = findrob(index , nums , dp);
        return ans;

    } 
            
};
// ==============>>>> bottom-up or tabulation appoach <<<<============
class Solution {
public:
    int findrob(int index , vector<int>&nums , vector<int> &dp){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          
          dp[0] = nums[0];

          
          for(int i = 1 ; i <= index ; i++){
            // i == 1 to return karoge ya kuch to hoga na 
            int pick = nums[i]; 
            if(i>1){
               pick = nums[i] + dp[i-2];
            }
            int donotpick = 0 + dp[i-1];
             dp[i] = max(pick , donotpick);
          }
          
          return dp[index];
       
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int n = nums.size();
        vector<int>dp(n );
        int ans = findrob(index , nums , dp);
        return ans;

    } 
            
};
====>>>> Another way previous one is more better than curr
class Solution {
public:
    int findrob(int index, vector<int>& nums, vector<int>& dp) {
        // Base cases
        if (index == 0) return nums[index];
        if (index == 1) return max(nums[0], nums[1]);

        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);

        for (int i = 2; i <= index; i++) {
            int pick = nums[i] + dp[i - 2];
            int donotpick = dp[i - 1];
            dp[i] = max(pick, donotpick);
        }

        return dp[index];
    }

    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        vector<int> dp(n);
        int ans = findrob(n - 1, nums, dp);
        return ans;
    }
};

// ==============>>>> space optimisation <<<===============
class Solution {
public:
    int findrob(int index , vector<int>&nums , vector<int> &dp){
        // understand the approach 
        // ===>>> base case <<=====
          if(index == 0) return nums[index];
          
           int prev = nums[0];
           int prev2 = 0;

          
          for(int i = 1 ; i <= index ; i++){
            // i == 1 to return karoge ya kuch to hoga na 
            int pick = nums[i]; 
            if(i>1){
               pick = nums[i] + prev2;
            }
            int donotpick = 0 + prev;
             int curr = max(pick , donotpick);
             prev2 = prev;
             prev = curr;
          }
          
          return prev;
       
    }
    int rob(vector<int>& nums) {
        int index =  nums.size() -1;
        // return maximum amount of money
        int n = nums.size();
        vector<int>dp(n );
        int ans = findrob(index , nums , dp);
        return ans;

    } 
            
};


/// ===============>>>> Q6)House Robber (DP 6) <<<===============
===============>>>>> VERY IMPORTATN QUESTION HAI <<<<<===========
class Solution {
public:
    int findrobcicle(int index, vector<int>& nums, vector<int>& dp) {
        if (index == 0) return nums[0];
        if (index < 0) return 0;

        if (dp[index] != -1) return dp[index];

        int pick = nums[index] + findrobcicle(index - 2, nums, dp);
        int dontpick = findrobcicle(index - 1, nums, dp);

        dp[index] = max(pick, dontpick);
        return dp[index];
    }

    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];

        vector<int> dp1(n, -1);
        vector<int> dp2(n, -1);

        // MOST IMPORTANT PART OF THE CODE ==>>> must know how it is working
        vector<int> temp1(nums.begin(), nums.end() - 1); // Exclude last house
        vector<int> temp2(nums.begin() + 1, nums.end()); // Exclude first house

        int rob1 = findrobcicle(n - 2, temp1, dp1); // n - 2 because last index in temp1 is n-2
        int rob2 = findrobcicle(n - 2, temp2, dp2); // n - 2 because last index in temp2 is n-2

        return max(rob1, rob2);
    }
};

// =======================>>>> Q7) Geek's Training or 	Ninja's Training (DP 7)   <<<=========================
// =================>>> Very very important Question hai must remember type question <<<===========
==>>> Abb sach me majja anne laggga hai code karne me bahut majja aa raaha hai <<<============
  public:
    int findmaximumPoints(int index , int last , vector<vector<int>>&points , vector<vector<int>>&dp){
        // very very important Question to understant in better way
        // base case hai 
        if(index == 0){
            int maxi = 0;
            for(int i = 0 ; i < points[0].size(); i++){
                if(i != last){
                    maxi = max(maxi , points[0][i]);
                }
            }
            return maxi;
        }
        
        if(dp[index][last] != -1){
            return dp[index][last];
        }
        
        // ===>>> jab choice karna hai 3 me ek then take loop check all the possible way
        int maxi =0;
        for(int i = 0 ; i <3 ; i++){
            if(last != i){
                int temp =  points[index][i] +  findmaximumPoints(index - 1 , i , points , dp);
                maxi = max(maxi , temp);
            }
        }
        dp[index][last] = maxi;
        return  dp[index][last];
    }
    int maximumPoints(vector<vector<int>>& points, int n) {
       // first we have to think of the index and if neccesary then take one variable  for next 
       int last = points[0].size();   // jaruri nahi yahi initialise karo last = -1 kar sakte hai 
       //applying dp
       vector<vector<int>>dp(n , vector<int>(last , -1));
       int ans =  findmaximumPoints(n-1 , last  , points , dp);

       return ans;
    }
};

// ============================>>> more better way <<==

#include <bits/stdc++.h>
using namespace std;

// Recursive function to calculate the maximum points for the ninja training
int f(int day, int last, vector<vector<int>> &points, vector<vector<int>> &dp) {
  // If the result for this day and last activity is already calculated, return it
  if (dp[day][last] != -1) return dp[day][last];

  // Base case: When we reach the first day (day == 0)
  if (day == 0) {
    int maxi = 0;
    // Calculate the maximum points for the first day by choosing an activity
    // different from the last one
    for (int i = 0; i <= 2; i++) {
      if (i != last)
        maxi = max(maxi, points[0][i]);
    }
    // Store the result in dp array and return it
    return dp[day][last] = maxi;
  }

  int maxi = 0;
  // Iterate through the activities for the current day
  for (int i = 0; i <= 2; i++) {
    if (i != last) {
      // Calculate the points for the current activity and add it to the
      // maximum points obtained so far (recursively calculated)
      int activity = points[day][i] + f(day - 1, i, points, dp);
      maxi = max(maxi, activity);
    }
  }

  // Store the result in dp array and return it
  return dp[day][last] = maxi;
}

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>> &points) {
  // Create a memoization table (dp) to store intermediate results
  vector<vector<int>> dp(n, vector<int>(4, -1));
  // Start the recursive calculation from the last day with no previous activity
  return f(n - 1, 3, points, dp);
}

// ============>>> Tabulation method <<<===============
// ==============>>>> 2D dp me initilaise base condition ko acche se karna hota hai to dhayan me rakhan 
#include <bits/stdc++.h>
using namespace std;

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>>& points) {
  // Create a 2D DP (Dynamic Programming) table to store the maximum points
  // dp[i][j] represents the maximum points at day i, considering the last activity as j
  vector<vector<int>> dp(n, vector<int>(4, 0));

  // Initialize the DP table for the first day (day 0)
  dp[0][0] = max(points[0][1], points[0][2]);
  dp[0][1] = max(points[0][0], points[0][2]);
  dp[0][2] = max(points[0][0], points[0][1]);
  dp[0][3] = max(points[0][0], max(points[0][1], points[0][2]));

  // Iterate through the days starting from day 1
  for (int day = 1; day < n; day++) {
    for (int last = 0; last < 4; last++) {
      dp[day][last] = 0;
      // Iterate through the tasks for the current day
      for (int task = 0; task <= 2; task++) {
        if (task != last) {
          // Calculate the points for the current activity and add it to the
          // maximum points obtained on the previous day (recursively calculated)
          int activity = points[day][task] + dp[day - 1][task];
          // Update the maximum points for the current day and last activity
          dp[day][last] = max(dp[day][last], activity);
        }
      }
    }
  }

  // The maximum points for the last day with any activity can be found in dp[n-1][3]
  return dp[n - 1][3];
}

// ======================>>>>>>>>>>Q8)Grid Unique Paths : DP on Grids (DP8)   <<<<<==========================================
//====>>> brute force approach <<<===
class Solution {
public:
    int finduniquepaths(int down , int  right ){
        if(down == 0 && right == 0){
            return 1;
        }
        if (down < 0 || right < 0) {
            return 0;
        }

        int dn = finduniquepaths(down -1 , right);
        int rt = finduniquepaths(down , right -1);

        return dn + rt;
    }
    int uniquePaths(int m, int n) {
        int ans = finduniquepaths(m-1 , n-1);
        return ans;
    }
};

// ===========>>> memoization <<<===============
#include <bits/stdc++.h>
using namespace std;

// Recursive function to count the number of ways to reach (i, j) from (0, 0)
// in a grid of size m x n
int countWaysUtil(int i, int j, vector<vector<int>>& dp) {
    // Base case: If we reach the top-left corner (0, 0), there is one way.
    if (i == 0 && j == 0)
        return 1;

    // If we go out of bounds or reach a blocked cell, there are no ways.
    if (i < 0 || j < 0)
        return 0;

    // If we have already computed the number of ways for this cell, return it.
    if (dp[i][j] != -1)
        return dp[i][j];

    // Calculate the number of ways by moving up and left recursively.
    int up = countWaysUtil(i - 1, j, dp);
    int left = countWaysUtil(i, j - 1, dp);

    // Store the result in the dp table and return it.
    return dp[i][j] = up + left;
}


// ===========>>>  Tabulation <<<======================

#include <bits/stdc++.h>
using namespace std;

// Function to count the number of ways to reach the bottom-right cell (m-1, n-1)
// from the top-left cell (0, 0) in a grid of size m x n
int countWaysUtil(int m, int n, vector<vector<int>>& dp) {
    // Loop through the grid using two nested loops
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // Base condition: If we are at the top-left cell (0, 0), there is one way.
            if (i == 0 && j == 0) {
                dp[i][j] = 1;
                continue; // Skip the rest of the loop and continue with the next iteration.
            }

            // Initialize variables to store the number of ways from the cell above (up) and left (left).
            int up = 0;
            int left = 0;

            // If we are not at the first row (i > 0), update 'up' with the value from the cell above.
            if (i > 0)
                up = dp[i - 1][j];

            // If we are not at the first column (j > 0), update 'left' with the value from the cell to the left.
            if (j > 0)
                left = dp[i][j - 1];

            // Calculate the number of ways to reach the current cell by adding 'up' and 'left'.
            dp[i][j] = up + left;
        }
    }

    // The result is stored in the bottom-right cell (m-1, n-1).
    return dp[m - 1][n - 1];
}

// ====>> space optimisation will be done after coding round or when i will have time <<<=====
#include <bits/stdc++.h>
using namespace std;

// Function to count the number of ways to reach the bottom-right cell (m-1, n-1)
// from the top-left cell (0, 0) in a grid of size m x n
int countWays(int m, int n) {
    // Create a vector to represent the previous row of the grid.
    vector<int> prev(n, 0);

    // Iterate through the rows of the grid.
    for (int i = 0; i < m; i++) {
        // Create a temporary vector to represent the current row.
        vector<int> temp(n, 0);

        // Iterate through the columns of the grid.
        for (int j = 0; j < n; j++) {
            // Base case: If we are at the top-left cell (0, 0), there is one way.
            if (i == 0 && j == 0) {
                temp[j] = 1;
                continue;
            }

            // Initialize variables to store the number of ways from the cell above (up) and left (left).
            int up = 0;
            int left = 0;

            // If we are not at the first row (i > 0), update 'up' with the value from the previous row.
            if (i > 0)
                up = prev[j];

            // If we are not at the first column (j > 0), update 'left' with the value from the current row.
            if (j > 0)
                left = temp[j - 1];

            // Calculate the number of ways to reach the current cell by adding 'up' and 'left'.
            temp[j] = up + left;
        }

        // Update the previous row with the values calculated for the current row.
        prev = temp;
    }

    // The result is stored in the last cell of the previous row (n-1).
    return prev[n - 1];
}


// ==========================>>>> Q9) Grid Unique Paths 2 (DP 9)  <<<=============================================

class Solution {
public:
    int  finduniquepathwithobstacle(int i , int j , vector<vector<int>>& obstacleGrid , vector<vector<int>> &dp ){
        if(i == 0  && j == 0 && obstacleGrid[i][j] != 1){
            return dp[i][j] = 1;
        }
        if(i < 0 || j < 0){
            return 0;
        }
        if(obstacleGrid[i][j] == 1){
            return 0;
        }
        if(dp[i][j] != -1){
            return dp[i][j];
        }

        int up = finduniquepathwithobstacle(i-1 , j , obstacleGrid , dp );
        int left = finduniquepathwithobstacle(i , j-1 , obstacleGrid  , dp);
        dp[i][j] = up + left;
        return dp[i][j];
    }
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(n == 0 && m == 0){
            return 0;
        }
        vector<vector<int>>dp(m , vector<int>(n , -1));
        int ans =  finduniquepathwithobstacle(m-1 , n-1 , obstacleGrid , dp);
        return ans;
    }
};

============>>> ye bhi dekh lena time mile to same hi hai <<<======
int mazeObstaclesUtil(int i, int j, vector<vector<int>> &maze, vector<vector<int>> &dp) {
    // Base cases
    if (i > 0 && j > 0 && maze[i][j] == -1) return 0; // If there's an obstacle at (i, j), return 0
    if (i == 0 && j == 0) return 1; // If we reach the destination (0, 0), return 1
    if (i < 0 || j < 0) return 0; // If we go out of bounds, return 0
    if (dp[i][j] != -1) return dp[i][j]; // If the result is already computed, return it

    // Recursive calls to explore paths from (i, j) to (0, 0)
    int up = mazeObstaclesUtil(i - 1, j, maze, dp);
    int left = mazeObstaclesUtil(i, j - 1, maze, dp);

    // Store the result in the DP table and return it
    return dp[i][j] = up + left;
}

// Main function to count paths with obstacles in a maze
int mazeObstacles(int n, int m, vector<vector<int>> &maze) {
    vector<vector<int>> dp(n, vector<int>(m, -1)); // DP table to memoize results
    return mazeObstaclesUtil(n - 1, m - 1, maze, dp); // Start from the bottom-right corner
}






// =========================>>> Q10 )Minimum path sum in Grid (DP 10) <<===========
===============>>>> must know the some edge case where it can fails 
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int findMinPathSum(int i, int j, vector<vector<int>>& grid, vector<vector<long>>& dp) {
        if (i == 0 && j == 0) {
            return grid[0][0];
        }

        // Boundary check
        if (i < 0 || j < 0) {
            return INT_MAX; // Out of bounds
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        long left = INT_MAX, up = INT_MAX;

        if (j > 0) {
            left = grid[i][j] + findMinPathSum(i, j - 1, grid, dp);
        }
        if (i > 0) {
            up = grid[i][j] + findMinPathSum(i - 1, j, grid, dp);
        }

        dp[i][j] = min(left, up);
        return dp[i][j];
    }

    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<long>> dp(m, vector<long>(n, -1));
        return findMinPathSum(m - 1, n - 1, grid, dp);
    }
};
=====>>> tabulation <<===========
#include <bits/stdc++.h>
using namespace std;

// Function to find the minimum sum path from (0, 0) to (n-1, m-1) in the matrix
int minSumPath(int n, int m, vector<vector<int>> &matrix) {
    vector<vector<int>> dp(n, vector<int>(m, 0)); // Initialize a DP table to store minimum path sums

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0)
                dp[i][j] = matrix[i][j]; // If we are at the top-left corner, the minimum path sum is the value at (0, 0)
            else {
                // Calculate the minimum path sum considering moving up and moving left
                int up = matrix[i][j];
                if (i > 0)
                    up += dp[i - 1][j]; // Include the minimum path sum from above
                else
                    up += 1e9; // A large value if moving up is not possible (out of bounds)

                int left = matrix[i][j];
                if (j > 0)
                    left += dp[i][j - 1]; // Include the minimum path sum from the left
                else
                    left += 1e9; // A large value if moving left is not possible (out of bounds)

                // Store the minimum path sum in dp[i][j]
                dp[i][j] = min(up, left);
            }
        }
    }

    // The final result is stored in dp[n-1][m-1], which represents the destination
    return dp[n - 1][m - 1];
}


// =====================>>>> Q11)Minimum path sum in Triangular Grid (DP 11)  <<==========================
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int findmin(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp) {
        int m = triangle.size();
        if (i == m - 1) return triangle[m - 1][j];
        
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        
        // down 
        int down = triangle[i][j] + findmin(i + 1, j, triangle, dp);
        
        // diagonal 
        int diagonal = triangle[i][j] + findmin(i + 1, j + 1, triangle, dp);
        
        dp[i][j] = min(down, diagonal);
        return dp[i][j];
    }
    
    int minimumTotal(vector<vector<int>>& triangle) {
        int m = triangle.size();
        int n = triangle[m - 1].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        int ans = findmin(0, 0, triangle, dp);
        return ans;
    }
};

// ===>>> Tabulation <<============

#include <bits/stdc++.h>
using namespace std;

// Function to find the minimum path sum in the given triangle using dynamic programming
int minimumPathSum(vector<vector<int> > &triangle, int n) {
    // Create a 2D DP (dynamic programming) array to store minimum path sums
    vector<vector<int> > dp(n, vector<int>(n, 0));

    // Initialize the bottom row of dp with the values from the triangle
    for (int j = 0; j < n; j++) {
        dp[n - 1][j] = triangle[n - 1][j];
    }

    // Iterate through the triangle rows in reverse order
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i; j >= 0; j--) {
            // Calculate the minimum path sum for the current cell
            int down = triangle[i][j] + dp[i + 1][j];
            int diagonal = triangle[i][j] + dp[i + 1][j + 1];

            // Store the minimum of the two possible paths in dp
            dp[i][j] = min(down, diagonal);
        }
    }

    // The top-left cell of dp now contains the minimum path sum
    return dp[0][0];
}



// ===================================>>>>Q12) Minimum/Maximum Falling Path Sum (DP-12) <<<======================================
class Solution {
public:
    int findminFallingPathSum(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp) {
        // Base case: out of boundary
        if (j >= matrix[0].size() || j < 0) {
            return 1e9; // large number to signify an invalid path
        }
        // Base case: top row
        if (i == 0) {
            return matrix[0][j];
        }

        // Check if the result is already computed
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        // Recursive calculation of minimum path sum
        int up = matrix[i][j] + findminFallingPathSum(i - 1, j, matrix, dp);
        int ldig = matrix[i][j] + findminFallingPathSum(i - 1, j - 1, matrix, dp);
        int rdig = matrix[i][j] + findminFallingPathSum(i - 1, j + 1, matrix, dp);

        dp[i][j] = min(up, min(ldig, rdig));
        return dp[i][j];
    }

    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if (n == 0 || matrix[0].size() == 0) {
            return 0; // edge case: empty matrix
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));

        int mini = INT_MAX;
        for (int i = 0; i < n; i++) {
            int value = findminFallingPathSum(n - 1, i, matrix, dp);
            mini = min(mini, value);
        }
        return mini;
    }
};

// ====================>>>> Q13)3-d DP : Ninja and his friends (DP-13) <<===============================
#include <bits/stdc++.h>
using namespace std;

int findmaximum(int i, int j1, int j2, vector<vector<int>> &grid) {
    int row = grid.size();
    int col = grid[0].size();

    // boundary check
    if(j1 < 0 || j1 >= col || j2 < 0 || j2 >= col){
        return -1e8;  // using a large negative value instead of INT_MIN
    }

    // base case
    if(i == row - 1){
        // same cell taken value once 
        if(j1 == j2){
            return grid[i][j1];
        } else {
            return grid[i][j1] + grid[i][j2];
        }
    }

    // all possible moves
    int dir[] = {-1, 0, 1};
    int maxi = INT_MIN;
    for(int di = 0; di < 3; di++) {
        for(int dj = 0; dj < 3; dj++) {
            int newJ1 = j1 + dir[di];
            int newJ2 = j2 + dir[dj];
            int path;
            if(j1 == j2){
                path = grid[i][j1] + findmaximum(i + 1, newJ1, newJ2, grid);
            } else {
                path = grid[i][j1] + grid[i][j2] + findmaximum(i + 1, newJ1, newJ2, grid);
            }
            maxi = max(maxi, path);
        }
    }
    return maxi;
}

int maximumChocolates(int r, int c, vector<vector<int>> &grid) {
    return findmaximum(0, 0, c - 1, grid);
}

======>>> memoization <<<================
#include <bits/stdc++.h>
using namespace std;

int findmaximum(int i, int j1, int j2, vector<vector<int>> &grid , vector<vector<vector<int>>> &dp) {
    int row = grid.size();
    int col = grid[0].size();

    // boundary check
    if(j1 < 0 || j1 >= col || j2 < 0 || j2 >= col){
        return -1e8;  // using a large negative value instead of INT_MIN
    }

    // base case
    if(i == row - 1){
        // same cell taken value once 
        if(j1 == j2){
            return grid[i][j1];
        } else {
            return grid[i][j1] + grid[i][j2];
        }
    }
    if(dp[i][j1][j2] != -1){
        return dp[i][j1][j2];
    }

    // all possible moves
    int dir[] = {-1, 0, 1};
    int maxi = INT_MIN;
    for(int di = 0; di < 3; di++) {
        for(int dj = 0; dj < 3; dj++) {
            int newJ1 = j1 + dir[di];
            int newJ2 = j2 + dir[dj];
            int path;
            if(j1 == j2){
                path = grid[i][j1] + findmaximum(i + 1, newJ1, newJ2, grid , dp);
            } else {
                path = grid[i][j1] + grid[i][j2] + findmaximum(i + 1, newJ1, newJ2, grid , dp);
            }
            maxi = max(maxi, path);
        }
    }
    dp[i][j1][j2] = maxi;

    return dp[i][j1][j2];
}

int maximumChocolates(int r, int c, vector<vector<int>> &grid) {
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, -1)));
    return findmaximum(0, 0, c - 1, grid , dp);
} 

========>>>> Tabulation (due  rahega kabhi or karege ) <=====








//============================================>>>>*************************<<<<<==============================================
//============================================>>>>>> DP ON SUBSEQUENCES <<<<<<================================================
//============================================>>>>*************************<<<<<==============================================

Q14) ========================>>>>> Subset sum equal to target (DP- 14)  <<<======================
// =======>>> brute force approach <<<<====
class Solution{   
public:
    bool findisSubsetsum(int index , int sum , vector<int>&arr){
        if(index == 0 && sum != 0){
            return false;
        }
        if(sum == 0){
            return true;
        }
        
        // pick 
        bool pick = false;
        if(arr[index -1] <= sum){
            pick = findisSubsetsum(index -1 , sum - arr[index -1] , arr);
        }
        
        // dont pick 
        bool notpick = findisSubsetsum(index -1 , sum  , arr);
        
        
        return pick || notpick ;
    }
    bool isSubsetSum(vector<int>arr, int sum){
        int n = arr.size();
        bool ans = findisSubsetsum(n-1 , sum , arr);
        return ans;
    }
};

//==========>>> memoization <<<=======
class Solution{   
public:
    bool findisSubsetsum(int index , int sum , vector<int>&arr , vector<vector<int>>&dp){
       
        if(sum == 0){
            return true;
        }
        if(index == 0){
            return arr[0] == sum;
        }
        
        if(dp[index][sum] != -1){
            return dp[index][sum];
        }
        
        
        // dont pick 
        bool notpick = findisSubsetsum(index -1 , sum  , arr , dp);
        
        
        // pick 
        bool pick = false;
        if(arr[index] <= sum){
            pick = findisSubsetsum(index -1 , sum - arr[index] , arr , dp);
        }
        
        dp[index][sum] = pick || notpick;
        
        return dp[index][sum];
    }
    bool isSubsetSum(vector<int>arr, int sum){
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(sum + 1, -1)); 
        bool ans = findisSubsetsum(n-1 , sum , arr , dp);
        return ans;
    }
};

// ========>>> Tabulation jarurii nahi hai <<<=====>> easy hi hai <<<=============



// ===========================>>> Q2) Partition Equal Subset Sum (DP- 15)  <<<====
privously have done this question in aditya dp lec
======>>> stivar bhaiya <<<====
class Solution {
public:
    bool canpartition(int index , int sum , vector<int>&nums , vector<vector<int>> &dp){
        if(sum == 0) return true;

        if(index == 0){
            return nums[0] == sum;
        }

        if(dp[index][sum] != -1){
            return dp[index][sum];
        }

        // donot pick 
        bool notpick =  canpartition(index -1 , sum  , nums , dp);

        // pick 
        bool pick = false;
        if(nums[index] <= sum){
            pick =  canpartition(index -1 , sum - nums[index] , nums , dp);
        }

        dp[index][sum] = pick || notpick;
        return dp[index][sum];
    }
    bool canPartition(vector<int>& nums) {
        
        // memoization code 
        int n = nums.size();
        if(n == 1) return false; 
        int sum = 0;
        for(int i = 0; i < nums.size()  ; i++){
            sum = sum + nums[i];
        }

        if(sum % 2 != 0){
            return false;
        }
        int W = sum/2;
        vector<vector<int>>dp(n , vector<int>(W+1 , -1));
        bool ans = canpartition(n-1 , W, nums , dp);
        return ans;
    }
};

// =============================>>> Q3) Count Subsets with Sum K (DP - 17)   <<<==========================================


=====>>> EK BAAR ISS QUESTION KO DEKHNA HAI <<<<==============
// ==>>> brute force code <<<<============ 
....... give TLE ........
complexity :- 2^n
0 ≤ arr[i] ≤ 10^6 ===>>> N = 10^6 VERY LARGE DEFENETILY GIVE TLE ====>>> THINK OF DP
#include <vector>

class Solution {
  const int MOD = 1e9 + 7;

public:
    void countsumsubseq(int index, int arr[], int n, int sum, int value, int &count) {
        if (value == sum) {
            count = (count + 1) % MOD;
            return;
        }

        if (index >= n || value > sum) {
            return;
        }

        // Include the current element
        countsumsubseq(index + 1, arr, n, sum, value + arr[index], count);

        // Exclude the current element
        countsumsubseq(index + 1, arr, n, sum, value, count);
    }

    int perfectSum(int arr[], int n, int sum) {
        int count = 0;
        countsumsubseq(0, arr, n, sum, 0, count);
        return count;
    }
};
=======================>>> memoization method <<<+
 
public:
    const int MOD = 1000000007;

    int findcount(int index, int sum, int arr[], vector<vector<int>>& dp) {
        if (sum == 0) {
            return 1;
        }
        
        if (index < 0) {
            return 0;
        }

        if (dp[index][sum] != -1) {
            return dp[index][sum];
        }
        
        // don't pick the current element
        int notpick = findcount(index - 1, sum, arr, dp) % MOD;
        
        // pick the current element
        int pick = 0;
        if (arr[index] <= sum) {
            pick = findcount(index - 1, sum - arr[index], arr, dp) % MOD;
        }
        
        dp[index][sum] = (notpick + pick) % MOD;
        return dp[index][sum];
    }

    int perfectSum(int arr[], int n, int sum) {
        vector<vector<int>> dp(n, vector<int>(sum + 1, -1));
        return findcount(n - 1, sum, arr, dp);
    }
};
#include <vector>
using namespace std;
#include <vector>
using namespace std;

class Solution {
public:
    const int MOD = 1e9 + 7;

    int countperfectsum(int arr[], int sum, int n, vector<vector<int>>& dp) {
      // Initialisation of the code     
        
      // making 1 row zero of dp array 
       for(int j = 0  ; j <= sum ; j++){
           dp[0][j] = 0;
       }
       
       // making 1st column to 1
       for(int i = 0 ; i <= n ; i++){
           dp[i][0] = 1;
       }
       
       // main code 
       for(int i = 1 ; i <= n  ; i ++){
           for(int j = 0  ; j <= sum ; j++){
               if(arr[i-1] <= j){
                   dp[i][j] = (dp[i-1][j-arr[i-1]] + dp[i-1][j]) % MOD;
               }
               else if(arr[i-1] > j){
                   dp[i][j] = dp[i-1][j];
               }
           }
       }
       return dp[n][sum];
       
    }

    int perfectSum(int arr[], int n, int sum) {
        // Initialize the dp table with -1
        vector<vector<int>> dp(n + 1, vector<int>(sum + 1));
        return countperfectsum(arr, sum, n, dp);
    }
};



